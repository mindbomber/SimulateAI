<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Performance Monitoring Loop Fix - SimulateAI</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <style>
      .monitor-status {
        padding: 10px;
        margin: 5px 0;
        border-radius: 5px;
      }
      .active {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
      }
      .disabled {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
      }
      .console-output {
        background: #1a1a1a;
        color: #00ff00;
        font-family: "Courier New", monospace;
        padding: 15px;
        border-radius: 5px;
        max-height: 400px;
        overflow-y: auto;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <div class="container mt-4">
      <h1>Performance Monitoring Loop Fix</h1>
      <p class="text-muted">
        Disabling performance monitoring systems to prevent infinite DOM loops
      </p>

      <div class="row">
        <div class="col-md-6">
          <div class="card">
            <div class="card-header">
              <h5>Monitoring Systems Status</h5>
            </div>
            <div class="card-body">
              <div id="app-monitoring" class="monitor-status active">
                <strong>App Monitoring:</strong>
                <span id="app-status">Active</span>
              </div>
              <div id="maingrid-monitoring" class="monitor-status active">
                <strong>MainGrid Monitoring:</strong>
                <span id="maingrid-status">Active</span>
              </div>
              <div id="performance-tracking" class="monitor-status active">
                <strong>Performance Tracking:</strong>
                <span id="perf-status">Active</span>
              </div>
              <div id="health-checks" class="monitor-status active">
                <strong>Health Checks:</strong>
                <span id="health-status">Active</span>
              </div>

              <hr />

              <button id="disable-all" class="btn btn-warning me-2">
                Disable All Monitoring
              </button>
              <button id="enable-all" class="btn btn-success me-2">
                Enable All Monitoring
              </button>
              <button id="test-classroom" class="btn btn-primary">
                Test Classroom Creation
              </button>
            </div>
          </div>
        </div>

        <div class="col-md-6">
          <div class="card">
            <div class="card-header">
              <h5>Quick Actions</h5>
            </div>
            <div class="card-body">
              <button id="emergency-stop" class="btn btn-danger mb-2">
                üö® Emergency Stop All Intervals
              </button>
              <button id="selective-disable" class="btn btn-warning mb-2">
                Disable Performance Only
              </button>
              <button id="clean-intervals" class="btn btn-info mb-2">
                Clean All Intervals
              </button>
              <button id="check-intervals" class="btn btn-secondary mb-2">
                Check Active Intervals
              </button>

              <hr />

              <div class="mb-3">
                <label for="test-duration" class="form-label"
                  >Test Duration (seconds):</label
                >
                <input
                  type="number"
                  class="form-control"
                  id="test-duration"
                  value="30"
                  min="5"
                  max="300"
                />
              </div>
              <button id="timed-disable" class="btn btn-warning">
                Temporary Disable
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="row mt-4">
        <div class="col-12">
          <div class="card">
            <div class="card-header">
              <h5>Monitoring Output</h5>
            </div>
            <div class="card-body">
              <div id="monitoring-output" class="console-output">
                === Performance Monitoring Fix Tool === Ready to disable
                problematic monitoring systems...
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script type="module">
      let monitoringState = {
        appIntervals: [],
        mainGridIntervals: [],
        performanceIntervals: [],
        originalSetInterval: null,
        originalSetTimeout: null,
        disabledIntervals: [],
        isMonitoringDisabled: false,
      };

      // Console output
      function addOutput(message) {
        const output = document.getElementById("monitoring-output");
        const timestamp = new Date().toLocaleTimeString();
        const line = `[${timestamp}] ${message}`;
        output.textContent += "\n" + line;
        output.scrollTop = output.scrollHeight;
      }

      function updateStatus(elementId, status, active) {
        const element = document.getElementById(elementId);
        const statusSpan = element.querySelector("span");
        statusSpan.textContent = status;
        element.className = `monitor-status ${active ? "active" : "disabled"}`;
      }

      // Override setInterval to track intervals
      function interceptIntervals() {
        if (monitoringState.originalSetInterval) return; // Already intercepted

        monitoringState.originalSetInterval = window.setInterval;
        monitoringState.originalSetTimeout = window.setTimeout;

        window.setInterval = function (callback, delay, ...args) {
          const intervalId = monitoringState.originalSetInterval.call(
            this,
            callback,
            delay,
            ...args,
          );

          // Track this interval
          const intervalInfo = {
            id: intervalId,
            callback: callback.toString().substring(0, 100),
            delay: delay,
            created: new Date().toISOString(),
          };

          // Categorize the interval based on callback content
          const callbackStr = callback.toString();
          if (
            callbackStr.includes("performanceCheck") ||
            callbackStr.includes("_performPerformanceCheck")
          ) {
            monitoringState.performanceIntervals.push(intervalInfo);
            addOutput(`üîç Performance interval detected: ${delay}ms`);
          } else if (
            callbackStr.includes("healthCheck") ||
            callbackStr.includes("_performHealthCheck")
          ) {
            monitoringState.appIntervals.push(intervalInfo);
            addOutput(`‚ù§Ô∏è Health check interval detected: ${delay}ms`);
          } else if (
            callbackStr.includes("telemetry") ||
            callbackStr.includes("monitoring")
          ) {
            monitoringState.mainGridIntervals.push(intervalInfo);
            addOutput(`üìä Telemetry interval detected: ${delay}ms`);
          }

          return intervalId;
        };

        addOutput("‚úÖ Interval interception enabled");
      }

      // Emergency stop all intervals
      function emergencyStopAllIntervals() {
        addOutput("üö® EMERGENCY STOP - Clearing all intervals...");

        // Get all interval IDs by brute force
        let stoppedCount = 0;
        for (let i = 1; i < 10000; i++) {
          try {
            clearInterval(i);
            stoppedCount++;
          } catch (e) {
            // Ignore errors
          }
        }

        addOutput(`üõë Stopped ${stoppedCount} intervals (brute force method)`);

        // Clear our tracking arrays
        monitoringState.appIntervals = [];
        monitoringState.mainGridIntervals = [];
        monitoringState.performanceIntervals = [];

        updateStatus("app-monitoring", "Stopped", false);
        updateStatus("maingrid-monitoring", "Stopped", false);
        updateStatus("performance-tracking", "Stopped", false);
        updateStatus("health-checks", "Stopped", false);
      }

      // Disable performance monitoring specifically
      function disablePerformanceMonitoring() {
        addOutput("‚ö†Ô∏è Disabling performance monitoring intervals...");

        // Clear performance intervals
        monitoringState.performanceIntervals.forEach((interval) => {
          clearInterval(interval.id);
          addOutput(`Cleared performance interval: ${interval.id}`);
        });

        // Try to access global app instance and disable monitoring
        if (window.app && window.app.performanceMonitoringInterval) {
          clearInterval(window.app.performanceMonitoringInterval);
          window.app.performanceMonitoringInterval = null;
          addOutput("Disabled app performance monitoring");
        }

        // Try to access MainGrid instance
        if (window.mainGrid && window.mainGrid.performanceMonitoringInterval) {
          clearInterval(window.mainGrid.performanceMonitoringInterval);
          window.mainGrid.performanceMonitoringInterval = null;
          addOutput("Disabled MainGrid performance monitoring");
        }

        updateStatus("performance-tracking", "Disabled", false);
        monitoringState.performanceIntervals = [];
      }

      // Disable all monitoring systems
      function disableAllMonitoring() {
        addOutput("üîÑ Disabling all monitoring systems...");

        // Disable app monitoring
        if (window.app) {
          if (window.app.healthCheckInterval) {
            clearInterval(window.app.healthCheckInterval);
            window.app.healthCheckInterval = null;
          }
          if (window.app.performanceMonitoringInterval) {
            clearInterval(window.app.performanceMonitoringInterval);
            window.app.performanceMonitoringInterval = null;
          }
          if (window.app.telemetryFlushInterval) {
            clearInterval(window.app.telemetryFlushInterval);
            window.app.telemetryFlushInterval = null;
          }
          addOutput("‚úÖ App monitoring disabled");
        }

        // Disable MainGrid monitoring
        if (window.mainGrid) {
          if (window.mainGrid.healthCheckInterval) {
            clearInterval(window.mainGrid.healthCheckInterval);
            window.mainGrid.healthCheckInterval = null;
          }
          if (window.mainGrid.performanceMonitoringInterval) {
            clearInterval(window.mainGrid.performanceMonitoringInterval);
            window.mainGrid.performanceMonitoringInterval = null;
          }
          if (window.mainGrid.telemetryFlushInterval) {
            clearInterval(window.mainGrid.telemetryFlushInterval);
            window.mainGrid.telemetryFlushInterval = null;
          }
          addOutput("‚úÖ MainGrid monitoring disabled");
        }

        // Clear tracked intervals
        [
          ...monitoringState.appIntervals,
          ...monitoringState.mainGridIntervals,
          ...monitoringState.performanceIntervals,
        ].forEach((interval) => {
          clearInterval(interval.id);
        });

        monitoringState.isMonitoringDisabled = true;
        updateStatus("app-monitoring", "Disabled", false);
        updateStatus("maingrid-monitoring", "Disabled", false);
        updateStatus("performance-tracking", "Disabled", false);
        updateStatus("health-checks", "Disabled", false);

        addOutput("üéâ All monitoring systems disabled");
      }

      // Check what intervals are currently active
      function checkActiveIntervals() {
        addOutput("üîç Checking for active intervals...");

        // Check app instance
        if (window.app) {
          addOutput(
            `App health check: ${window.app.healthCheckInterval ? "Active" : "Inactive"}`,
          );
          addOutput(
            `App performance: ${window.app.performanceMonitoringInterval ? "Active" : "Inactive"}`,
          );
          addOutput(
            `App telemetry: ${window.app.telemetryFlushInterval ? "Active" : "Inactive"}`,
          );
        } else {
          addOutput("App instance not found");
        }

        // Check MainGrid instance
        if (window.mainGrid) {
          addOutput(
            `MainGrid health check: ${window.mainGrid.healthCheckInterval ? "Active" : "Inactive"}`,
          );
          addOutput(
            `MainGrid performance: ${window.mainGrid.performanceMonitoringInterval ? "Active" : "Inactive"}`,
          );
          addOutput(
            `MainGrid telemetry: ${window.mainGrid.telemetryFlushInterval ? "Active" : "Inactive"}`,
          );
        } else {
          addOutput("MainGrid instance not found");
        }

        addOutput(
          `Tracked intervals: App(${monitoringState.appIntervals.length}), MainGrid(${monitoringState.mainGridIntervals.length}), Performance(${monitoringState.performanceIntervals.length})`,
        );
      }

      // Test classroom creation with monitoring disabled
      async function testClassroomCreation() {
        addOutput("üè´ Testing classroom creation with monitoring disabled...");

        try {
          // Import the classroom modules
          const { default: DataHandler } = await import(
            "./src/js/core/data-handler.js"
          );
          const { FirebaseService } = await import(
            "./src/js/services/firebase-service.js"
          );
          const { default: TeacherClassroomModals } = await import(
            "./src/js/components/teacher-classroom-modals.js"
          );

          // Initialize services
          const firebaseService = new FirebaseService();
          await firebaseService.initialize({ enableOffline: true });

          const dataHandler = new DataHandler({
            appName: "SimulateAI",
            version: "1.80",
            firebaseService: firebaseService,
          });
          await dataHandler.initialize();

          const teacherModals = new TeacherClassroomModals(
            dataHandler,
            firebaseService,
          );
          await teacherModals.initialize(true);

          addOutput("‚úÖ Services initialized successfully");

          // Try to create a test classroom
          const classroomData = {
            classroomName: "Monitoring Test Classroom",
            instructorId: "test_instructor_" + Date.now(),
            instructorName: "Test Instructor",
            selectedScenarios: [{ id: "test1", title: "Test Scenario" }],
          };

          const result =
            await teacherModals.classroomService.createClassroom(classroomData);
          addOutput(
            `üéâ Classroom created successfully: ${result.classroomCode}`,
          );
        } catch (error) {
          addOutput(`‚ùå Classroom creation failed: ${error.message}`);
        }
      }

      // Temporary disable with timer
      function temporaryDisable() {
        const duration =
          parseInt(document.getElementById("test-duration").value) * 1000;
        addOutput(
          `‚è∞ Temporarily disabling monitoring for ${duration / 1000} seconds...`,
        );

        disableAllMonitoring();

        setTimeout(() => {
          addOutput(
            "‚è∞ Temporary disable period ended - you can re-enable monitoring if needed",
          );
        }, duration);
      }

      // Event listeners
      document
        .getElementById("emergency-stop")
        .addEventListener("click", emergencyStopAllIntervals);
      document
        .getElementById("selective-disable")
        .addEventListener("click", disablePerformanceMonitoring);
      document
        .getElementById("disable-all")
        .addEventListener("click", disableAllMonitoring);
      document
        .getElementById("check-intervals")
        .addEventListener("click", checkActiveIntervals);
      document
        .getElementById("test-classroom")
        .addEventListener("click", testClassroomCreation);
      document
        .getElementById("timed-disable")
        .addEventListener("click", temporaryDisable);

      document
        .getElementById("clean-intervals")
        .addEventListener("click", () => {
          monitoringState.appIntervals = [];
          monitoringState.mainGridIntervals = [];
          monitoringState.performanceIntervals = [];
          addOutput("üßπ Cleared interval tracking arrays");
        });

      // Initialize
      addOutput("Performance monitoring fix tool loaded");
      addOutput(
        'Click "Check Active Intervals" to see current monitoring status',
      );
      addOutput(
        'Use "Emergency Stop All Intervals" to stop the infinite loop immediately',
      );

      // Auto-intercept intervals
      interceptIntervals();

      // Check status after a moment
      setTimeout(checkActiveIntervals, 2000);
    </script>
  </body>
</html>
