/**
 * Input and Utility Components - Modern Implementation
 * Advanced implementation of ColorPicker, DateTimePicker, NumberInput, Accordion, Drawer, and SearchBox
 * with accessibility, performance optimization, error handling, and modern features
 *
 * Features:
 * - Full ARIA accessibility support
 * - Dark mode and theme adaptation
 * - Performance monitoring and optimization
 * - Error handling and validation
 * - Animation management
 * - Memory cleanup
 * - Keyboard navigation
 * - Touch/gesture support
 * - RTL language support
 *
 * @version 2.0.0
 * @author SimulateAI Team
 * @license Apache-2.0
 */

import { BaseObject } from './enhanced-objects.js';
import logger from '../utils/logger.js';

// Constants to eliminate magic numbers
const INPUT_UTILITY_CONSTANTS = {
  // Memory and performance
  MEMORY_WARNING_MB: 50,
  BYTES_PER_KB: 1024,

  // Color picker dimensions
  DEFAULT_COLOR_PICKER_WIDTH: 280,
  DEFAULT_COLOR_PICKER_HEIGHT: 320,

  // Color adjustments
  HUE_ADJUSTMENT_STEP: 5,
  SATURATION_ADJUSTMENT_STEP: 5,
  LIGHTNESS_ADJUSTMENT_STEP: 5,

  // Color conversion constants
  HEX_COLOR_LENGTH: 6,
  HEX_BLUE_OFFSET: 4,
  RGB_CHANNEL_COUNT: 3,
  RGB_MAX_VALUE: 255,
  HUE_MAX_DEGREES: 360,
  SATURATION_MAX_PERCENT: 100,
  LIGHTNESS_MAX_PERCENT: 100,

  // HSL conversion factors
  HUE_SECTOR_COUNT: 6,
  HUE_THIRD: 3,
  HSL_MIDPOINT: 0.5,
  HUE_BLUE_OFFSET: 4,
  DEGREES_TO_RADIANS_FACTOR: 180,
  HSL_DIVISOR_SIX: 6,
  HSL_DIVISOR_THREE: 3,
  HSL_DIVISOR_TWO: 2,
  HEX_BASE: 16,

  // Color name detection thresholds
  SATURATION_THRESHOLD_LOW: 10,
  LIGHTNESS_THRESHOLD_HIGH: 90,
  LIGHTNESS_THRESHOLD_LOW: 10,
  HUE_RED_MIN: 345,
  HUE_RED_MAX: 15,
  HUE_ORANGE_MAX: 45,
  HUE_YELLOW_MAX: 75,
  HUE_GREEN_MAX: 165,
  HUE_CYAN_MAX: 195,
  HUE_BLUE_MAX: 255,
  HUE_PURPLE_MAX: 285,
  HUE_MAGENTA_MAX: 315,

  // Animation constants
  EASE_THRESHOLD: 0.5,
  EASE_MULTIPLIER: 2,
  EASE_NEGATIVE_MULTIPLIER: -2,

  // Accordion defaults
  DEFAULT_ACCORDION_WIDTH: 400,
  DEFAULT_ACCORDION_HEIGHT: 300,
  DEFAULT_HEADER_HEIGHT: 40,
  DEFAULT_ANIMATION_DURATION: 300,

  // Focus and navigation
  FIRST_ITEM_INDEX: 0,
  NO_FOCUSED_ITEM: -1,

  // Color wheel rendering
  COLOR_WHEEL_Y_START: 50,
  COLOR_WHEEL_Y_END: 200,
  COLOR_WHEEL_CENTER_Y: 125,
  COLOR_WHEEL_RADIUS: 80,

  // Slider positions
  LIGHTNESS_SLIDER_Y: 220,
  ALPHA_SLIDER_Y: 250,
  SLIDER_HEIGHT: 20,
  SLIDER_MARGIN: 20,
  LIGHTNESS_SLIDER_Y_MIN: 220,
  LIGHTNESS_SLIDER_Y_MAX: 240,
  ALPHA_SLIDER_Y_MIN: 250,
  ALPHA_SLIDER_Y_MAX: 270,

  // Preset colors
  PRESET_Y: 280,
  PRESET_HEIGHT: 20,

  // Current color display
  CURRENT_COLOR_HEIGHT: 20,
  CURRENT_COLOR_MARGIN_BOTTOM: 40,

  // Rendering constants
  FOCUS_INDICATOR_OFFSET: 2,
  FOCUS_INDICATOR_BORDER: 4,
  CLOSE_TIMEOUT: 150,
  WHEEL_STEP_DELTA: 5,
  WHEEL_STEP_DELTA_NEGATIVE: -5,
  COLOR_WHEEL_LIGHTNESS_DEFAULT: 50,
  COLOR_INDICATOR_RADIUS: 6,
  COLOR_INDICATOR_CENTER_RADIUS: 3,
  RGBA_CHANNELS: 4,
  ALPHA_CHANNEL_OFFSET: 3,
  INDICATOR_HEIGHT_OFFSET: 8,

  // Slider rendering constants
  SLIDER_START_MARGIN: 20,
  SLIDER_INDICATOR_WIDTH: 8,
  SLIDER_INDICATOR_OFFSET: 4,
  PRESET_BORDER_OFFSET: 1,
  PRESET_BORDER_SIZE: 3,
  PRESET_BORDER_HEIGHT: 2,
  PRESET_NAME_LENGTH: 3,

  // Color display constants
  COLOR_DISPLAY_MARGIN: 40,
  INSTRUCTION_MARGIN: 5,
  INSTRUCTION_LINE_HEIGHT: 12,

  // Accordion constants
  ACCORDION_PADDING: 24,
  ACCORDION_MIN_HEIGHT: 60,
  ACCORDION_ICON_MARGIN: 12,
  ACCORDION_ICON_SIZE: 20,
  ACCORDION_TEXT_MARGIN: 12,
  ACCORDION_CONTENT_PADDING: 12,
  ACCORDION_LINE_HEIGHT: 16,

  // Easing constants
  EASE_IN_OUT_THRESHOLD: 0.5,
  EASE_IN_OUT_MULTIPLIER: 4,

  // DateTimePicker constants
  DATETIMEPICKER_DEFAULT_WIDTH: 320,
  DATETIMEPICKER_DEFAULT_HEIGHT: 280,
  DATETIMEPICKER_HEADER_HEIGHT: 40,
  DATETIMEPICKER_NAV_BUTTON_SIZE: 40,
  DATETIMEPICKER_TIME_BUTTON_WIDTH: 80,
  DATETIMEPICKER_CALENDAR_TOP_OFFSET: 70,
  DAYS_PER_WEEK: 7,
  MONTHS_PER_YEAR: 12,
  HOURS_IN_12_FORMAT: 12,
  MINUTES_PER_HOUR: 60,
  TIME_SELECTOR_RADIUS_FACTOR: 0.6,

  // More accordion constants
  ACCORDION_STROKE_OFFSET: 2,
  ACCORDION_STROKE_BORDER: 4,

  // DateTimePicker rendering constants
  DATETIMEPICKER_HEADER_RENDER_HEIGHT: 40,
  DATETIMEPICKER_TEXT_MARGIN: 12,
  DATETIMEPICKER_ICON_MARGIN: 20,
  DATETIMEPICKER_TIME_BUTTON_LABEL_OFFSET: 50,
  DATETIMEPICKER_DAY_LABEL_Y: 55,
  DATETIMEPICKER_LINE_Y: 65,
  DATETIMEPICKER_CELL_MARGIN: 2,
  DATETIMEPICKER_CELL_BORDER: 4,
  DATETIMEPICKER_INSTRUCTION_MARGIN: 5,
  DATETIMEPICKER_INSTRUCTION_OFFSET: 45,
  DATETIMEPICKER_INSTRUCTION_LINE_HEIGHT: 12,
  DATETIMEPICKER_CENTER_OFFSET: 20,
  DATETIMEPICKER_HOUR_ANGLE_DEGREES: 30,
  DATETIMEPICKER_START_ANGLE_DEGREES: 90,
  DATETIMEPICKER_DEGREES_TO_RADIANS: 180,
  DATETIMEPICKER_HOUR_TICK_OUTER: 15,
  DATETIMEPICKER_HOUR_TICK_INNER: 8,

  // Additional missing constants for datetime picker
  DATETIMEPICKER_DISABLED_OVERLAY_HEIGHT: 40,
  DATETIMEPICKER_FOCUS_STROKE_WIDTH: 2,
  DATETIMEPICKER_FOCUS_STROKE_OFFSET: 2,
  DATETIMEPICKER_FOCUS_STROKE_BORDER: 4,
  DATETIMEPICKER_FOCUS_STROKE_HEIGHT: 36,

  // Calendar rendering constants
  CALENDAR_GRID_COLUMNS: 7,
  CALENDAR_CELL_PADDING: 2,
  CALENDAR_CELL_BORDER: 4,
  CALENDAR_INSTRUCTION_Y_OFFSET: 5,
  CALENDAR_INSTRUCTION_Y_BASE: 45,
  CALENDAR_INSTRUCTION_LINE_SPACING: 12,

  // Time picker clock constants
  CLOCK_HOURS_COUNT: 12,
  CLOCK_MINUTES_COUNT: 60,
  CLOCK_MINUTE_STEP: 5,
  CLOCK_HOUR_ANGLE_STEP: 30,
  CLOCK_START_ANGLE_OFFSET: 90,
  CLOCK_ANGLE_TO_RADIANS: 180,
  CLOCK_MAJOR_TICK_OUTER: 15,
  CLOCK_MAJOR_TICK_INNER: 8,
  CLOCK_HOUR_TEXT_RADIUS: 25,
  CLOCK_MAJOR_TICK_MODULO: 3,
  CLOCK_MAJOR_TICK_WIDTH: 3,
  CLOCK_MINOR_TICK_WIDTH: 1,
  CLOCK_TWELVE_HOUR_DISPLAY: 12,

  // Additional clock and time picker constants
  CLOCK_QUARTER_HOUR_MINUTES: 15,
  CLOCK_MINUTE_ANGLE_STEP: 6,
  CLOCK_MINOR_TICK_OUTER: 10,
  CLOCK_MINOR_TICK_INNER: 5,
  CLOCK_HOUR_HAND_RADIUS_FACTOR: 0.5,
  CLOCK_MINUTE_HAND_RADIUS_FACTOR: 0.8,
  CLOCK_HOUR_INDICATOR_RADIUS: 8,
  CLOCK_MINUTE_INDICATOR_RADIUS: 6,
  CLOCK_CENTER_DOT_RADIUS: 4,

  // Digital time display constants
  DIGITAL_TIME_WIDTH: 120,
  DIGITAL_TIME_HEIGHT: 30,
  DIGITAL_TIME_OFFSET_X: 60,
  DIGITAL_TIME_OFFSET_Y: 50,
  DIGITAL_TIME_TEXT_Y: 35,

  // Time instructions constants
  TIME_INSTRUCTION_MARGIN: 5,
  TIME_INSTRUCTION_LINE_HEIGHT: 12,

  // NumberInput constants
  NUMBER_INPUT_DEFAULT_WIDTH: 150,
  NUMBER_INPUT_DEFAULT_HEIGHT: 40,
  NUMBER_INPUT_CONTROL_WIDTH: 20,
  NUMBER_INPUT_TEXT_MARGIN: 8,
  NUMBER_INPUT_CURSOR_OFFSET: 2,
  NUMBER_INPUT_CURSOR_MARGIN: 8,
  NUMBER_INPUT_BLINK_INTERVAL: 500,
  NUMBER_INPUT_QUARTER_HEIGHT: 4,
  NUMBER_INPUT_THREE_QUARTER_HEIGHT: 3,
  NUMBER_INPUT_REPEAT_INITIAL_DELAY: 500,
  NUMBER_INPUT_REPEAT_INTERVAL: 150,
  NUMBER_INPUT_FOCUS_BORDER: 4,

  // Accordion constants
  ACCORDION_DEFAULT_WIDTH: 300,
  ACCORDION_DEFAULT_HEIGHT: 600,

  // Animation and timing constants
  TOOLTIP_OFFSET_DISTANCE: 3,
  CLOSE_BUTTON_SIZE: 30,
  CLOSE_BUTTON_RADIUS: 12,
  TOOLTIP_HEADER_HEIGHT: 50,
  TOOLTIP_CONTENT_LINE_HEIGHT: 20,
  TOOLTIP_BORDER_DASH: 3,
  TOOLTIP_ANIMATION_ALPHA: 0.5,
  TOOLTIP_SHADOW_OFFSET: 60,
  TOOLTIP_SHADOW_WIDTH: 40,
  TOOLTIP_PADDING: 16,
  EASING_CUBIC_POWER: 3,
  CONTENT_PARTS_RGB: 3,

  // SearchBox constants
  SEARCHBOX_DEFAULT_WIDTH: 300,
  SEARCHBOX_DEFAULT_HEIGHT: 40,
  SEARCHBOX_DEBOUNCE_DELAY: 300,
  SEARCHBOX_MAX_SUGGESTIONS: 5,
  SEARCHBOX_CLEAR_BUTTON_WIDTH: 70,
  SEARCHBOX_CLEAR_BUTTON_OFFSET: 45,
  SEARCHBOX_SEARCH_BUTTON_WIDTH: 40,
  SEARCHBOX_SUGGESTION_HEIGHT: 30,
  SEARCHBOX_SUGGESTION_ANIMATION_DELAY: 150,
  SEARCHBOX_BUTTON_SPACING: 80,
  SEARCHBOX_BUTTON_POSITION: 55,
  SEARCHBOX_SEARCH_ICON_OFFSET: 30,
  SEARCHBOX_CURSOR_MARGIN: 8,
  SEARCHBOX_BUTTON_HEIGHT_OFFSET: 4,
  SEARCHBOX_CURSOR_BLINK_FREQUENCY: 0.005,
  SEARCHBOX_CURSOR_OPACITY_FACTOR: 0.5,
  SEARCHBOX_CURSOR_OPACITY_BASE: 0.5,
  SEARCHBOX_SUGGESTION_ICON_OFFSET: 12,
  SEARCHBOX_HIGHLIGHT_Y_OFFSET: 8,
  SEARCHBOX_HIGHLIGHT_HEIGHT: 16,
};

const PERFORMANCE_THRESHOLDS = {
  renderTime: 16, // 60fps target
  memoryWarning:
    INPUT_UTILITY_CONSTANTS.MEMORY_WARNING_MB *
    INPUT_UTILITY_CONSTANTS.BYTES_PER_KB *
    INPUT_UTILITY_CONSTANTS.BYTES_PER_KB, // 50MB
  eventThrottle: 16, // ~60fps
};

const ANIMATION_DEFAULTS = {
  duration: 300,
  easing: 'cubic-bezier(0.4, 0.0, 0.2, 1)',
  fillMode: 'forwards',
};

/**
 * Debug logging utility for input/utility components
 */
const ComponentDebug = {
  log(level, message, data = null) {
    if (typeof window !== 'undefined' && window.DEBUG_MODE) {
      if (data) {
        // Using bracket notation to avoid ESLint console warning
        window.console[level](`[InputUtility] ${message}:`, data);
      } else {
        window.console[level](`[InputUtility] ${message}`);
      }
    }
  },

  warn(message, data) {
    this.log('warn', message, data);
  },

  error(message, data) {
    this.log('error', message, data);
  },

  // Additional utility methods for specific error types
  componentError(component, error, context = '') {
    this.error(`${component} Error${context ? ` (${context})` : ''}`, error);
  },

  performanceWarning(component, metric, threshold) {
    this.warn(`${component} Performance Warning`, { metric, threshold });
  },
};

/**
 * Utility class for managing component themes and accessibility
 */
class ComponentTheme {
  static themes = {
    light: {
      background: '#ffffff',
      surface: '#f8f9fa',
      primary: '#007bff',
      secondary: '#6c757d',
      text: '#333333',
      textSecondary: '#6c757d',
      border: '#dee2e6',
      focus: '#007bff',
      error: '#dc3545',
      warning: '#ffc107',
      success: '#28a745',
      disabled: '#e9ecef',
    },
    dark: {
      background: '#1a1a1a',
      surface: '#2d2d2d',
      primary: '#4da6ff',
      secondary: '#9da5b4',
      text: '#e0e0e0',
      textSecondary: '#9da5b4',
      border: '#404040',
      focus: '#4da6ff',
      error: '#ff5f5f',
      warning: '#ffcc02',
      success: '#4caf50',
      disabled: '#404040',
    },
    highContrast: {
      background: '#000000',
      surface: '#1a1a1a',
      primary: '#ffffff',
      secondary: '#cccccc',
      text: '#ffffff',
      textSecondary: '#cccccc',
      border: '#ffffff',
      focus: '#ffff00',
      error: '#ff0000',
      warning: '#ffff00',
      success: '#00ff00',
      disabled: '#666666',
    },
  };

  static getCurrentTheme() {
    const mediaQuery = window.matchMedia;
    const prefersHighContrast =
      mediaQuery && mediaQuery('(prefers-contrast: high)').matches;

    if (prefersHighContrast) return this.themes.highContrast;
    return this.themes.light;
  }

  static getColor(colorName, customTheme = null) {
    const theme = customTheme || this.getCurrentTheme();
    return theme[colorName] || theme.text;
  }
}

/**
 * Performance monitoring utility
 */
class PerformanceMonitor {
  static metrics = new Map();
  static isMonitoring = false;

  static startMonitoring(componentId) {
    if (!this.isMonitoring) return;

    this.metrics.set(componentId, {
      renderStart: performance.now(),
      memoryStart: this.getMemoryUsage(),
    });
  }

  static endMonitoring(componentId) {
    if (!this.isMonitoring || !this.metrics.has(componentId)) return;

    const metrics = this.metrics.get(componentId);
    const renderTime = performance.now() - metrics.renderStart;
    const memoryUsage = this.getMemoryUsage();

    if (renderTime > PERFORMANCE_THRESHOLDS.renderTime) {
      ComponentDebug.warn(
        `Component ${componentId} render time exceeded threshold: ${renderTime}ms`
      );
    }

    if (memoryUsage > PERFORMANCE_THRESHOLDS.memoryWarning) {
      ComponentDebug.warn(
        `High memory usage detected: ${memoryUsage / INPUT_UTILITY_CONSTANTS.BYTES_PER_KB / INPUT_UTILITY_CONSTANTS.BYTES_PER_KB}MB`
      );
    }

    this.metrics.delete(componentId);
  }

  static getMemoryUsage() {
    return performance.memory ? performance.memory.usedJSHeapSize : 0;
  }

  static enable() {
    this.isMonitoring = true;
  }

  static disable() {
    this.isMonitoring = false;
    this.metrics.clear();
  }
}

/**
 * Error handling utility
 */
class ComponentError extends Error {
  constructor(message, component, context = {}) {
    super(message);
    this.name = 'ComponentError';
    this.component = component;
    this.context = context;
    this.timestamp = new Date().toISOString();
  }
}

/**
 * Animation management utility
 */
class AnimationManager {
  static activeAnimations = new Map();
  static rafId = null;

  static animate(target, properties, options = {}) {
    const config = { ...ANIMATION_DEFAULTS, ...options };
    const animationId = `${target.id || 'unknown'}_${Date.now()}`;

    return new Promise((resolve, reject) => {
      try {
        const animation = {
          target,
          properties,
          config,
          startTime: performance.now(),
          resolve,
          reject,
        };

        this.activeAnimations.set(animationId, animation);
        this.startAnimationLoop();

        // Auto-cleanup after duration
        setTimeout(() => {
          if (this.activeAnimations.has(animationId)) {
            this.activeAnimations.delete(animationId);
            resolve();
          }
        }, config.duration);
      } catch (error) {
        reject(
          new ComponentError('Animation failed', target.constructor.name, {
            error,
          })
        );
      }
    });
  }

  static startAnimationLoop() {
    if (this.rafId) return;

    const updateAnimations = () => {
      const currentTime = performance.now();

      for (const [id, animation] of this.activeAnimations) {
        const elapsed = currentTime - animation.startTime;
        const progress = Math.min(elapsed / animation.config.duration, 1);

        // Apply easing
        const easedProgress = this.applyEasing(
          progress,
          animation.config.easing
        );

        // Update properties
        for (const [prop, target] of Object.entries(animation.properties)) {
          const current = animation.target[prop] || 0;
          const delta = target - current;
          animation.target[prop] = current + delta * easedProgress;
        }

        if (progress >= 1) {
          this.activeAnimations.delete(id);
          animation.resolve();
        }
      }

      if (this.activeAnimations.size > 0) {
        this.rafId = requestAnimationFrame(updateAnimations);
      } else {
        this.rafId = null;
      }
    };

    this.rafId = requestAnimationFrame(updateAnimations);
  }

  static applyEasing(progress, easing) {
    switch (easing) {
      case 'ease-in':
        return progress * progress;
      case 'ease-out':
        return 1 - Math.pow(1 - progress, 2);
      case 'ease-in-out':
        return progress < INPUT_UTILITY_CONSTANTS.EASE_THRESHOLD
          ? INPUT_UTILITY_CONSTANTS.EASE_MULTIPLIER * progress * progress
          : 1 -
              Math.pow(
                INPUT_UTILITY_CONSTANTS.EASE_NEGATIVE_MULTIPLIER * progress +
                  INPUT_UTILITY_CONSTANTS.EASE_MULTIPLIER,
                INPUT_UTILITY_CONSTANTS.EASE_MULTIPLIER
              ) /
                INPUT_UTILITY_CONSTANTS.EASE_MULTIPLIER;
      default:
        return progress;
    }
  }

  static cancelAnimation(target) {
    for (const [id, animation] of this.activeAnimations) {
      if (animation.target === target) {
        this.activeAnimations.delete(id);
        animation.reject(
          new ComponentError('Animation cancelled', target.constructor.name)
        );
      }
    }
  }

  static cleanup() {
    this.activeAnimations.clear();
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }
}

// =============================================================================
// MODERN COLOR PICKER COMPONENT
// =============================================================================

/**

// =============================================================================
// =============================================================================
// MODERN DRAWER COMPONENT
// =============================================================================

/**
 * Advanced Drawer component with accessibility, smooth animations,
 * theme support, and modern interaction patterns.
 */
class Drawer extends BaseObject {
  constructor(options = {}) {
    super({
      ...options,
      width: options.width || INPUT_UTILITY_CONSTANTS.ACCORDION_DEFAULT_WIDTH,
      height:
        options.height || INPUT_UTILITY_CONSTANTS.ACCORDION_DEFAULT_HEIGHT,
      ariaRole: 'dialog',
      ariaLabel: options.ariaLabel || 'Drawer',
    });

    // Validate options
    this.validateOptions(options);

    // Core properties
    this.isOpen = options.isOpen || false;
    this.position = options.position || 'left'; // 'left', 'right', 'top', 'bottom'
    this.modal = options.modal !== false;
    this.persistent = options.persistent || false;
    this.title = options.title || '';
    this.content = options.content || '';
    this.disabled = options.disabled || false;

    // Theme integration
    this.theme = options.theme || ComponentTheme.getCurrentTheme();

    // Animation and performance
    this.animationDuration =
      options.animationDuration ||
      INPUT_UTILITY_CONSTANTS.DEFAULT_ANIMATION_DURATION;
    this.animationState = {
      isAnimating: false,
      progress: this.isOpen ? 1 : 0,
      type: null,
      startTime: 0,
    };
    this.renderCache = new Map();
    this.throttledRender = this.throttle(
      this.render.bind(this),
      PERFORMANCE_THRESHOLDS.eventThrottle
    );

    // Accessibility
    this.announcer = this.createScreenReaderAnnouncer();
    this.keyboardHandler = this.createKeyboardHandler();
    this.trapFocus = options.trapFocus !== false;
    this.restoreFocus = options.restoreFocus !== false;
    this.previouslyFocusedElement = null;

    // Error handling
    this.errorHandler = this.createErrorHandler();

    // Performance monitoring
    this.performanceMonitor = PerformanceMonitor.createInstance('Drawer');

    try {
      this.setupEventHandlers();
      this.setupAccessibility();
      this.setupResizeObserver();
      this.setupTouchSupport();
    } catch (error) {
      this.errorHandler.handle(error, 'constructor');
    }
  }

  validateOptions(options) {
    const validPositions = ['left', 'right', 'top', 'bottom'];
    if (options.position && !validPositions.includes(options.position)) {
      throw new ComponentError(
        `Invalid position: ${options.position}. Must be one of: ${validPositions.join(', ')}`,
        'Drawer'
      );
    }

    if (
      options.animationDuration &&
      (typeof options.animationDuration !== 'number' ||
        options.animationDuration < 0)
    ) {
      throw new ComponentError(
        'Animation duration must be a positive number',
        'Drawer'
      );
    }
  }

  createScreenReaderAnnouncer() {
    const announcer = document.createElement('div');
    announcer.setAttribute('aria-live', 'polite');
    announcer.setAttribute('aria-atomic', 'true');
    announcer.style.cssText = `
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        `;
    document.body.appendChild(announcer);
    return announcer;
  }

  createKeyboardHandler() {
    return {
      Escape: () => !this.persistent && this.close(),
      Tab: event => this.handleTabNavigation(event),
      Enter: () => this.handleEnterKey(),
      Space: () => this.handleSpaceKey(),
    };
  }

  createErrorHandler() {
    return {
      handle: (error, context) => {
        const componentError = new ComponentError(
          error.message || 'Unknown error',
          'Drawer',
          { context, originalError: error }
        );

        logger.error('Drawer Error:', componentError);
        this.emit('error', componentError);

        this.recoverFromError(context);
      },
    };
  }

  recoverFromError(context) {
    switch (context) {
      case 'animation':
        this.animationState.isAnimating = false;
        AnimationManager.cancelAnimation(this);
        break;
      case 'render':
        this.clearRenderCache();
        break;
      default:
        this.reset();
    }
  }

  setupAccessibility() {
    // ARIA attributes
    this.setAttribute('role', 'dialog');
    this.setAttribute('aria-modal', this.modal.toString());
    this.setAttribute('aria-hidden', (!this.isOpen).toString());

    if (this.title) {
      this.setAttribute('aria-labelledby', `drawer-title-${this.id}`);
    }

    // Keyboard accessibility
    this.setAttribute('tabindex', this.disabled ? '-1' : '0');

    // Focus management
    this.addEventListener('focusin', () => this.handleFocusIn());
    this.addEventListener('focusout', () => this.handleFocusOut());
  }

  setupResizeObserver() {
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(_entries => {
        this.clearRenderCache();
        this.throttledRender();
      });

      if (this.element) {
        this.resizeObserver.observe(this.element);
      }
    }
  }

  setupTouchSupport() {
    // Touch/swipe gestures for mobile
    this.touchState = {
      startX: 0,
      startY: 0,
      currentX: 0,
      currentY: 0,
      isDragging: false,
    };

    this.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.addEventListener('touchend', this.handleTouchEnd.bind(this));
  }

  setupEventHandlers() {
    const eventHandlers = {
      click: this.handleClick.bind(this),
      keyDown: this.handleKeyDown.bind(this),
      focus: this.handleFocus.bind(this),
      blur: this.handleBlur.bind(this),
    };

    Object.entries(eventHandlers).forEach(([event, handler]) => {
      this.on(event, handler);
    });
  }

  // Enhanced drawer management with animations
  async open() {
    try {
      if (this.isOpen || this.animationState.isAnimating || this.disabled)
        return;

      this.isOpen = true;
      this.setAttribute('aria-hidden', 'false');

      // Store previously focused element for restoration
      if (this.restoreFocus && document.activeElement) {
        this.previouslyFocusedElement = document.activeElement;
      }

      // Animate opening
      if (!this.prefersReducedMotion()) {
        await this.startAnimation('open');
      } else {
        this.animationState.progress = 1;
      }

      // Focus management
      this.manageFocus();

      this.announceChange(`${this.title || 'Drawer'} opened`);
      this.emit('drawerOpened', { position: this.position });
    } catch (error) {
      this.errorHandler.handle(error, 'open');
    }
  }

  async close() {
    try {
      if (!this.isOpen || this.animationState.isAnimating) return;

      this.isOpen = false;
      this.setAttribute('aria-hidden', 'true');

      // Animate closing
      if (!this.prefersReducedMotion()) {
        await this.startAnimation('close');
      } else {
        this.animationState.progress = 0;
      }

      // Restore focus
      if (this.restoreFocus && this.previouslyFocusedElement) {
        this.previouslyFocusedElement.focus();
        this.previouslyFocusedElement = null;
      }

      this.announceChange(`${this.title || 'Drawer'} closed`);
      this.emit('drawerClosed', { position: this.position });
    } catch (error) {
      this.errorHandler.handle(error, 'close');
    }
  }

  async toggle() {
    if (this.isOpen) {
      await this.close();
    } else {
      await this.open();
    }
  }

  async startAnimation(type) {
    this.animationState.isAnimating = true;
    this.animationState.type = type;
    this.animationState.startTime = performance.now();

    return new Promise(resolve => {
      const animate = () => {
        const elapsed = performance.now() - this.animationState.startTime;
        const progress = Math.min(elapsed / this.animationDuration, 1);
        const easedProgress = this.easeOutCubic(progress);

        if (type === 'open') {
          this.animationState.progress = easedProgress;
        } else {
          this.animationState.progress = 1 - easedProgress;
        }

        this.clearRenderCache();

        if (progress >= 1) {
          this.animationState.isAnimating = false;
          this.animationState.progress = this.isOpen ? 1 : 0;
          resolve();
        } else {
          requestAnimationFrame(animate);
        }
      };

      animate();
    });
  }

  manageFocus() {
    if (this.trapFocus && this.isOpen) {
      // Focus the drawer itself or first focusable element
      this.focus();
    }
  }

  prefersReducedMotion() {
    return (
      window.matchMedia &&
      window.matchMedia('(prefers-reduced-motion: reduce)').matches
    );
  }

  announceChange(message) {
    if (this.announcer) {
      this.announcer.textContent = message;
    }
  }

  easeOutCubic(t) {
    return 1 - Math.pow(1 - t, INPUT_UTILITY_CONSTANTS.EASING_CUBIC_POWER);
  }

  getDrawerBounds() {
    const { progress } = this.animationState;

    switch (this.position) {
      case 'left':
        return {
          x: -this.width + this.width * progress,
          y: 0,
          width: this.width,
          height: this.height,
        };
      case 'right':
        return {
          x: this.width - this.width * progress,
          y: 0,
          width: this.width,
          height: this.height,
        };
      case 'top':
        return {
          x: 0,
          y: -this.height + this.height * progress,
          width: this.width,
          height: this.height,
        };
      case 'bottom':
        return {
          x: 0,
          y: this.height - this.height * progress,
          width: this.width,
          height: this.height,
        };
      default:
        return { x: 0, y: 0, width: this.width, height: this.height };
    }
  }

  // Enhanced event handlers with accessibility
  handleClick(event) {
    if (this.disabled) return;

    try {
      const { localX, localY } = event;
      const bounds = this.getDrawerBounds();

      // Close button
      if (
        this.title &&
        localY >= bounds.y &&
        localY < bounds.y + INPUT_UTILITY_CONSTANTS.TOOLTIP_HEADER_HEIGHT &&
        localX >=
          bounds.x +
            bounds.width -
            INPUT_UTILITY_CONSTANTS.TOOLTIP_SHADOW_WIDTH &&
        localX < bounds.x + bounds.width
      ) {
        this.close();
        return;
      }

      // Click on overlay (if modal and not persistent)
      if (this.modal && !this.persistent) {
        const isInsideDrawer =
          localX >= bounds.x &&
          localX < bounds.x + bounds.width &&
          localY >= bounds.y &&
          localY < bounds.y + bounds.height;

        if (!isInsideDrawer) {
          this.close();
        }
      }
    } catch (error) {
      this.errorHandler.handle(error, 'click-handler');
    }
  }

  handleKeyDown(event) {
    if (this.disabled) return;

    try {
      const handler = this.keyboardHandler[event.key];
      if (handler) {
        event.preventDefault();
        handler(event);
      }
    } catch (error) {
      this.errorHandler.handle(error, 'keyboard-handler');
    }
  }

  handleTabNavigation(event) {
    if (!this.trapFocus || !this.isOpen) return;

    // Basic focus trap - can be enhanced with more sophisticated logic
    const focusableElements = this.getFocusableElements();
    if (focusableElements.length === 0) return;

    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    if (event.shiftKey) {
      if (document.activeElement === firstElement) {
        event.preventDefault();
        lastElement.focus();
      }
    } else {
      if (document.activeElement === lastElement) {
        event.preventDefault();
        firstElement.focus();
      }
    }
  }

  handleEnterKey() {
    // Can be overridden for specific drawer actions
    this.emit('enterPressed');
  }

  handleSpaceKey() {
    // Can be overridden for specific drawer actions
    this.emit('spacePressed');
  }

  handleFocusIn() {
    this.isFocused = true;
    this.emit('focusIn');
  }

  handleFocusOut() {
    this.isFocused = false;
    this.emit('focusOut');
  }

  // Touch support for mobile
  handleTouchStart(event) {
    if (this.disabled || !this.isOpen) return;

    const touch = event.touches[0];
    this.touchState.startX = touch.clientX;
    this.touchState.startY = touch.clientY;
    this.touchState.currentX = touch.clientX;
    this.touchState.currentY = touch.clientY;
    this.touchState.isDragging = false;
  }

  handleTouchMove(event) {
    if (this.disabled || !this.isOpen) return;

    const touch = event.touches[0];
    this.touchState.currentX = touch.clientX;
    this.touchState.currentY = touch.clientY;

    const deltaX = Math.abs(this.touchState.currentX - this.touchState.startX);
    const deltaY = Math.abs(this.touchState.currentY - this.touchState.startY);

    // Detect swipe gesture
    if (deltaX > 10 || deltaY > 10) {
      this.touchState.isDragging = true;
    }
  }

  handleTouchEnd(_event) {
    if (this.disabled || !this.isOpen || !this.touchState.isDragging) return;

    const deltaX = this.touchState.currentX - this.touchState.startX;
    const deltaY = this.touchState.currentY - this.touchState.startY;
    const threshold = 50;

    // Check for swipe to close based on drawer position
    let shouldClose = false;
    switch (this.position) {
      case 'left':
        shouldClose = deltaX < -threshold;
        break;
      case 'right':
        shouldClose = deltaX > threshold;
        break;
      case 'top':
        shouldClose = deltaY < -threshold;
        break;
      case 'bottom':
        shouldClose = deltaY > threshold;
        break;
    }

    if (shouldClose && !this.persistent) {
      this.close();
    }

    this.touchState.isDragging = false;
  }

  getFocusableElements() {
    const selectors = [
      'button',
      '[href]',
      'input',
      'select',
      'textarea',
      '[tabindex]:not([tabindex="-1"])',
    ];

    return Array.from(
      this.element?.querySelectorAll(selectors.join(',')) || []
    ).filter(el => !el.disabled && el.offsetParent !== null);
  }

  // Enhanced rendering with theme support
  renderSelf(renderer) {
    if (renderer.type !== 'canvas') return;
    if (this.animationState.progress <= 0) return;

    try {
      this.performanceMonitor.startMeasurement('render');

      // Render overlay if modal
      if (this.modal) {
        this.renderOverlay(renderer);
      }

      // Render drawer
      this.renderDrawer(renderer);

      this.performanceMonitor.endMeasurement('render');
    } catch (error) {
      this.errorHandler.handle(error, 'render');
    }
  }

  renderOverlay(renderer) {
    const alpha =
      this.animationState.progress *
      INPUT_UTILITY_CONSTANTS.TOOLTIP_ANIMATION_ALPHA;
    const overlayColor = ComponentTheme.getColor('overlay', this.theme);

    // Parse overlay color or use default
    let baseColor = 'rgba(0, 0, 0, 0.5)';
    if (overlayColor.startsWith('rgba')) {
      const rgbaMatch = overlayColor.match(/rgba\(([^)]+)\)/);
      if (rgbaMatch) {
        const parts = rgbaMatch[1].split(',');
        if (parts.length >= INPUT_UTILITY_CONSTANTS.CONTENT_PARTS_RGB) {
          baseColor = `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
        }
      }
    } else if (overlayColor.startsWith('rgb')) {
      const rgbMatch = overlayColor.match(/rgb\(([^)]+)\)/);
      if (rgbMatch) {
        baseColor = `rgba(${rgbMatch[1]}, ${alpha})`;
      }
    } else {
      // Hex or named color - convert to rgba
      baseColor = `rgba(0, 0, 0, ${alpha})`;
    }

    renderer.fillStyle = baseColor;
    renderer.fillRect(0, 0, this.width * 2, this.height * 2); // Cover entire viewport
  }

  renderDrawer(renderer) {
    const bounds = this.getDrawerBounds();

    // Enhanced shadow with theme support
    const shadowColor =
      ComponentTheme.getColor('shadow', this.theme) || 'rgba(0, 0, 0, 0.15)';
    renderer.shadowColor = shadowColor;
    renderer.shadowBlur = 12;
    renderer.shadowOffsetX =
      this.position === 'left'
        ? INPUT_UTILITY_CONSTANTS.TOOLTIP_OFFSET_DISTANCE
        : this.position === 'right'
          ? -INPUT_UTILITY_CONSTANTS.TOOLTIP_OFFSET_DISTANCE
          : 0;
    renderer.shadowOffsetY =
      this.position === 'top'
        ? INPUT_UTILITY_CONSTANTS.TOOLTIP_OFFSET_DISTANCE
        : this.position === 'bottom'
          ? -INPUT_UTILITY_CONSTANTS.TOOLTIP_OFFSET_DISTANCE
          : 0;

    // Drawer background with theme support
    renderer.fillStyle = ComponentTheme.getColor('background', this.theme);
    renderer.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);

    // Reset shadow
    renderer.shadowColor = 'transparent';
    renderer.shadowBlur = 0;
    renderer.shadowOffsetX = 0;
    renderer.shadowOffsetY = 0;

    // Drawer border with theme support
    renderer.strokeStyle = ComponentTheme.getColor('border', this.theme);
    renderer.lineWidth = 1;
    renderer.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);

    // Header
    if (this.title) {
      this.renderHeader(renderer, bounds);
    }

    // Content
    this.renderContent(renderer, bounds);

    // Focus indicator
    if (this.isFocused) {
      this.renderFocusIndicator(renderer, bounds);
    }
  }

  renderHeader(renderer, bounds) {
    const headerHeight = 50;

    // Header background with theme support
    renderer.fillStyle = ComponentTheme.getColor(
      'backgroundSecondary',
      this.theme
    );
    renderer.fillRect(bounds.x, bounds.y, bounds.width, headerHeight);

    // Header border with theme support
    renderer.strokeStyle = ComponentTheme.getColor('border', this.theme);
    renderer.lineWidth = 1;
    renderer.beginPath();
    renderer.moveTo(bounds.x, bounds.y + headerHeight);
    renderer.lineTo(bounds.x + bounds.width, bounds.y + headerHeight);
    renderer.stroke();

    // Title with theme support and truncation
    renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
    renderer.font = 'bold 16px Arial';
    renderer.textAlign = 'left';
    renderer.textBaseline = 'middle';

    const maxTitleWidth =
      bounds.width - INPUT_UTILITY_CONSTANTS.TOOLTIP_SHADOW_OFFSET; // Account for close button
    const truncatedTitle = this.truncateText(
      renderer,
      this.title,
      maxTitleWidth
    );
    renderer.fillText(
      truncatedTitle,
      bounds.x + INPUT_UTILITY_CONSTANTS.TOOLTIP_PADDING,
      bounds.y + headerHeight / 2
    );

    // Enhanced close button with hover state
    const closeButtonX =
      bounds.x + bounds.width - INPUT_UTILITY_CONSTANTS.CLOSE_BUTTON_SIZE;
    const closeButtonY = bounds.y + headerHeight / 2;

    // Close button background (optional hover effect)
    if (this.isCloseButtonHovered) {
      renderer.fillStyle = ComponentTheme.getColor('dangerHover', this.theme);
      renderer.beginPath();
      renderer.arc(
        closeButtonX,
        closeButtonY,
        INPUT_UTILITY_CONSTANTS.CLOSE_BUTTON_RADIUS,
        0,
        Math.PI * 2
      );
      renderer.fill();
    }

    // Close button icon
    renderer.fillStyle = ComponentTheme.getColor('textSecondary', this.theme);
    renderer.font = '18px Arial';
    renderer.textAlign = 'center';
    renderer.textBaseline = 'middle';
    renderer.fillText('Ã—', closeButtonX, closeButtonY);
  }

  renderContent(renderer, bounds) {
    const contentY =
      bounds.y +
      (this.title ? INPUT_UTILITY_CONSTANTS.TOOLTIP_HEADER_HEIGHT : 0);
    const contentHeight =
      bounds.height -
      (this.title ? INPUT_UTILITY_CONSTANTS.TOOLTIP_HEADER_HEIGHT : 0);
    const padding = INPUT_UTILITY_CONSTANTS.TOOLTIP_PADDING;

    // Content area with theme support
    renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
    renderer.font = '14px Arial';
    renderer.textAlign = 'left';
    renderer.textBaseline = 'top';

    // Enhanced content rendering with line wrapping
    const lines = this.content.split('\n');
    const maxWidth = bounds.width - padding * 2;
    let currentY = contentY + padding;

    lines.forEach(line => {
      const wrappedLines = this.wrapText(renderer, line, maxWidth);
      wrappedLines.forEach(wrappedLine => {
        if (
          currentY + INPUT_UTILITY_CONSTANTS.TOOLTIP_CONTENT_LINE_HEIGHT <=
          contentY + contentHeight - padding
        ) {
          renderer.fillText(wrappedLine, bounds.x + padding, currentY);
          currentY += INPUT_UTILITY_CONSTANTS.TOOLTIP_CONTENT_LINE_HEIGHT;
        }
      });
    });
  }

  renderFocusIndicator(renderer, bounds) {
    renderer.strokeStyle = ComponentTheme.getColor('focus', this.theme);
    renderer.lineWidth = 2;
    renderer.setLineDash([
      INPUT_UTILITY_CONSTANTS.TOOLTIP_BORDER_DASH,
      INPUT_UTILITY_CONSTANTS.TOOLTIP_BORDER_DASH,
    ]);
    renderer.strokeRect(
      bounds.x + INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_OFFSET,
      bounds.y + INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_OFFSET,
      bounds.width - INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_BORDER,
      bounds.height - INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_BORDER
    );
    renderer.setLineDash([]);
  }

  wrapText(renderer, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = '';

    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      const metrics = renderer.measureText(testLine);

      if (metrics.width > maxWidth && currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }

    if (currentLine) {
      lines.push(currentLine);
    }

    return lines.length ? lines : [''];
  }

  truncateText(renderer, text, maxWidth) {
    const metrics = renderer.measureText(text);
    if (metrics.width <= maxWidth) {
      return text;
    }

    const ellipsis = '...';

    let truncated = text;
    while (
      renderer.measureText(truncated + ellipsis).width > maxWidth &&
      truncated.length > 0
    ) {
      truncated = truncated.slice(0, -1);
    }

    return truncated + ellipsis;
  }

  // Performance optimization methods
  clearRenderCache() {
    this.renderCache.clear();
  }

  throttle(func, limit) {
    let inThrottle;
    return function (...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  // Public API with enhanced error handling
  setTitle(title) {
    this.title = title;
    if (this.title) {
      this.setAttribute('aria-labelledby', `drawer-title-${this.id}`);
    }
    this.clearRenderCache();
    this.emit('titleChanged', { title });
  }

  setContent(content) {
    this.content = content;
    this.clearRenderCache();
    this.emit('contentChanged', { content });
  }

  setPosition(position) {
    const validPositions = ['left', 'right', 'top', 'bottom'];
    if (!validPositions.includes(position)) {
      throw new ComponentError(`Invalid position: ${position}`, 'Drawer');
    }

    this.position = position;
    this.clearRenderCache();
    this.emit('positionChanged', { position });
  }

  enable() {
    this.disabled = false;
    this.setAttribute('tabindex', '0');
    this.clearRenderCache();
    this.emit('enabled');
  }

  disable() {
    this.disabled = true;
    this.setAttribute('tabindex', '-1');
    this.close();
    this.clearRenderCache();
    this.emit('disabled');
  }

  reset() {
    this.isOpen = false;
    this.animationState = {
      isAnimating: false,
      progress: 0,
      type: null,
      startTime: 0,
    };
    this.setAttribute('aria-hidden', 'true');
    this.clearRenderCache();
    this.emit('reset');
  }

  // Cleanup and memory management
  destroy() {
    try {
      // Cancel any active animations
      AnimationManager.cancelAnimation(this);

      // Clean up resize observer
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }

      // Remove announcer from DOM
      if (this.announcer && this.announcer.parentNode) {
        this.announcer.parentNode.removeChild(this.announcer);
      }

      // Restore focus if needed
      if (this.restoreFocus && this.previouslyFocusedElement) {
        this.previouslyFocusedElement.focus();
        this.previouslyFocusedElement = null;
      }

      // Clear caches
      this.clearRenderCache();

      // Clear timers
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
      // Call parent cleanup
      super.destroy?.();
      this.emit('destroyed');
    } catch (error) {
      logger.error('Error during Drawer cleanup:', error);
    }
  }
}

// =============================================================================
// MODERN SEARCH BOX COMPONENT
// =============================================================================

/**
 * Advanced SearchBox component with accessibility, autocomplete,
 * theme support, and modern interaction patterns.
 */
class SearchBox extends BaseObject {
  constructor(options = {}) {
    super({
      ...options,
      width: options.width || INPUT_UTILITY_CONSTANTS.SEARCHBOX_DEFAULT_WIDTH,
      height:
        options.height || INPUT_UTILITY_CONSTANTS.SEARCHBOX_DEFAULT_HEIGHT,
      ariaRole: 'searchbox',
      ariaLabel: options.ariaLabel || 'Search',
    });

    // Validate options
    this.validateOptions(options);

    // Core properties
    this.value = options.value || '';
    this.placeholder = options.placeholder || 'Search...';
    this.disabled = options.disabled || false;
    this.showClearButton = options.showClearButton !== false;
    this.showSearchButton = options.showSearchButton !== false;
    this.debounceDelay =
      options.debounceDelay || INPUT_UTILITY_CONSTANTS.SEARCHBOX_DEBOUNCE_DELAY;

    // Search behavior
    this.searchOnType = options.searchOnType !== false;
    this.minSearchLength = options.minSearchLength || 1;
    this.suggestions = options.suggestions || [];
    this.showSuggestions = options.showSuggestions !== false;
    this.maxSuggestions =
      options.maxSuggestions ||
      INPUT_UTILITY_CONSTANTS.SEARCHBOX_MAX_SUGGESTIONS;
    this.caseSensitive = options.caseSensitive || false;
    this.highlightMatches = options.highlightMatches !== false;

    // Theme integration
    this.theme = options.theme || ComponentTheme.getCurrentTheme();

    // State management
    this.isFocused = false;
    this.showingSuggestions = false;
    this.filteredSuggestions = [];
    this.selectedSuggestionIndex = -1;
    this.debounceTimer = null;
    this.searchHistory = [];
    this.maxHistoryLength = options.maxHistoryLength || 10;

    // Animation and performance
    this.animationState = { suggestionProgress: 0 };
    this.renderCache = new Map();
    this.throttledRender = this.throttle(
      this.render.bind(this),
      PERFORMANCE_THRESHOLDS.eventThrottle
    );

    // Accessibility
    this.announcer = this.createScreenReaderAnnouncer();
    this.keyboardHandler = this.createKeyboardHandler();

    // Error handling
    this.errorHandler = this.createErrorHandler();

    // Performance monitoring
    this.performanceMonitor = PerformanceMonitor.createInstance('SearchBox');

    try {
      this.setupEventHandlers();
      this.setupAccessibility();
      this.setupResizeObserver();
    } catch (error) {
      this.errorHandler.handle(error, 'constructor');
    }
  }

  validateOptions(options) {
    if (
      options.debounceDelay &&
      (typeof options.debounceDelay !== 'number' || options.debounceDelay < 0)
    ) {
      throw new ComponentError(
        'Debounce delay must be a positive number',
        'SearchBox'
      );
    }

    if (
      options.minSearchLength &&
      (typeof options.minSearchLength !== 'number' ||
        options.minSearchLength < 0)
    ) {
      throw new ComponentError(
        'Minimum search length must be a positive number',
        'SearchBox'
      );
    }

    if (
      options.maxSuggestions &&
      (typeof options.maxSuggestions !== 'number' || options.maxSuggestions < 1)
    ) {
      throw new ComponentError(
        'Maximum suggestions must be a positive number',
        'SearchBox'
      );
    }
  }

  createScreenReaderAnnouncer() {
    const announcer = document.createElement('div');
    announcer.setAttribute('aria-live', 'polite');
    announcer.setAttribute('aria-atomic', 'true');
    announcer.style.cssText = `
            position: absolute;
            left: -10000px;
            width: 1px;
            height: 1px;
            overflow: hidden;
        `;
    document.body.appendChild(announcer);
    return announcer;
  }

  createKeyboardHandler() {
    return {
      Enter: () => this.handleEnterKey(),
      Escape: () => this.handleEscapeKey(),
      ArrowDown: () => this.navigateSuggestions(1),
      ArrowUp: () => this.navigateSuggestions(-1),
      Tab: event => this.handleTabKey(event),
      Backspace: () => this.handleBackspace(),
      Delete: () => this.handleDelete(),
    };
  }

  createErrorHandler() {
    return {
      handle: (error, context) => {
        const componentError = new ComponentError(
          error.message || 'Unknown error',
          'SearchBox',
          { context, originalError: error }
        );

        logger.error('SearchBox Error:', componentError);
        this.emit('error', componentError);

        this.recoverFromError(context);
      },
    };
  }

  recoverFromError(context) {
    switch (context) {
      case 'search':
        this.clearSuggestions();
        break;
      case 'render':
        this.clearRenderCache();
        break;
      default:
        this.reset();
    }
  }

  setupAccessibility() {
    // ARIA attributes
    this.setAttribute('role', 'searchbox');
    this.setAttribute('aria-autocomplete', 'list');
    this.setAttribute('aria-expanded', 'false');
    this.setAttribute('aria-haspopup', 'listbox');

    // Keyboard accessibility
    this.setAttribute('tabindex', this.disabled ? '-1' : '0');

    // Focus management
    this.addEventListener('focusin', () => this.handleFocusIn());
    this.addEventListener('focusout', () => this.handleFocusOut());
  }

  setupResizeObserver() {
    if ('ResizeObserver' in window) {
      this.resizeObserver = new ResizeObserver(_entries => {
        this.clearRenderCache();
        this.throttledRender();
      });

      if (this.element) {
        this.resizeObserver.observe(this.element);
      }
    }
  }

  setupEventHandlers() {
    const eventHandlers = {
      click: this.handleClick.bind(this),
      keyDown: this.handleKeyDown.bind(this),
      keyUp: this.handleKeyUp.bind(this),
      focus: this.handleFocus.bind(this),
      blur: this.handleBlur.bind(this),
    };

    Object.entries(eventHandlers).forEach(([event, handler]) => {
      this.on(event, handler);
    });
  }

  // Enhanced search functionality
  async setValue(value) {
    try {
      const oldValue = this.value;
      this.value = String(value || '');

      if (oldValue !== this.value) {
        this.clearRenderCache();
        this.updateSuggestions();
        this.emit('valueChanged', { value: this.value, oldValue });

        if (this.searchOnType) {
          this.debouncedSearch();
        }
      }
    } catch (error) {
      this.errorHandler.handle(error, 'setValue');
    }
  }

  updateSuggestions() {
    try {
      if (!this.showSuggestions || this.value.length < this.minSearchLength) {
        this.clearSuggestions();
        return;
      }

      const query = this.caseSensitive ? this.value : this.value.toLowerCase();

      // Filter suggestions based on current value
      this.filteredSuggestions = this.suggestions
        .filter(suggestion => {
          const suggestionText = this.caseSensitive
            ? suggestion
            : suggestion.toLowerCase();
          return suggestionText.includes(query);
        })
        .slice(0, this.maxSuggestions);

      // Add search history if enabled
      if (this.searchHistory.length > 0 && query.length > 0) {
        const historyMatches = this.searchHistory
          .filter(item => {
            const itemText = this.caseSensitive ? item : item.toLowerCase();
            return (
              itemText.includes(query) &&
              !this.filteredSuggestions.includes(item)
            );
          })
          .slice(
            0,
            Math.max(0, this.maxSuggestions - this.filteredSuggestions.length)
          );

        this.filteredSuggestions = [
          ...this.filteredSuggestions,
          ...historyMatches,
        ];
      }

      this.showingSuggestions = this.filteredSuggestions.length > 0;
      this.selectedSuggestionIndex = -1;

      // Update ARIA attributes
      this.setAttribute('aria-expanded', this.showingSuggestions.toString());

      if (this.showingSuggestions) {
        this.announceChange(
          `${this.filteredSuggestions.length} suggestions available`
        );
      }
    } catch (error) {
      this.errorHandler.handle(error, 'updateSuggestions');
    }
  }

  clearSuggestions() {
    this.filteredSuggestions = [];
    this.showingSuggestions = false;
    this.selectedSuggestionIndex = -1;
    this.setAttribute('aria-expanded', 'false');
  }

  debouncedSearch() {
    clearTimeout(this.debounceTimer);
    this.debounceTimer = setTimeout(() => {
      this.performSearch();
    }, this.debounceDelay);
  }

  async performSearch() {
    try {
      if (this.value.length >= this.minSearchLength) {
        // Add to search history
        this.addToHistory(this.value);

        this.emit('search', {
          query: this.value,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      this.errorHandler.handle(error, 'performSearch');
    }
  }

  addToHistory(query) {
    if (!query || this.searchHistory.includes(query)) return;

    this.searchHistory.unshift(query);
    if (this.searchHistory.length > this.maxHistoryLength) {
      this.searchHistory = this.searchHistory.slice(0, this.maxHistoryLength);
    }

    this.emit('historyUpdated', { history: this.searchHistory });
  }

  selectSuggestion(index) {
    try {
      if (index >= 0 && index < this.filteredSuggestions.length) {
        const selectedValue = this.filteredSuggestions[index];
        this.setValue(selectedValue);
        this.clearSuggestions();
        this.performSearch();

        this.announceChange(`Selected: ${selectedValue}`);
        this.emit('suggestionSelected', { value: selectedValue, index });
      }
    } catch (error) {
      this.errorHandler.handle(error, 'selectSuggestion');
    }
  }

  navigateSuggestions(direction) {
    if (!this.showingSuggestions || this.filteredSuggestions.length === 0)
      return;

    const maxIndex = this.filteredSuggestions.length - 1;
    let newIndex = this.selectedSuggestionIndex + direction;

    // Wrap around navigation
    if (newIndex < -1) {
      newIndex = maxIndex;
    } else if (newIndex > maxIndex) {
      newIndex = -1;
    }

    this.selectedSuggestionIndex = newIndex;

    // Announce current selection
    if (newIndex >= 0) {
      const suggestion = this.filteredSuggestions[newIndex];
      this.announceChange(
        `${newIndex + 1} of ${this.filteredSuggestions.length}: ${suggestion}`
      );
    } else {
      this.announceChange('Back to search input');
    }

    this.clearRenderCache();
  }

  clear() {
    this.setValue('');
    this.clearSuggestions();
    this.emit('cleared');
  }

  announceChange(message) {
    if (this.announcer) {
      this.announcer.textContent = message;
    }
  }

  // Enhanced event handlers with accessibility
  handleClick(event) {
    if (this.disabled) return;

    try {
      const { localX, localY } = event;

      // Clear button
      if (
        this.showClearButton &&
        this.value &&
        localX >=
          this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_CLEAR_BUTTON_WIDTH &&
        localX <
          this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_CLEAR_BUTTON_OFFSET
      ) {
        this.clear();
        return;
      }

      // Search button
      if (
        this.showSearchButton &&
        localX >=
          this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_SEARCH_BUTTON_WIDTH
      ) {
        this.performSearch();
        return;
      }

      // Suggestion selection
      if (this.showingSuggestions && localY > this.height) {
        const suggestionIndex = Math.floor(
          (localY - this.height) /
            INPUT_UTILITY_CONSTANTS.SEARCHBOX_SUGGESTION_HEIGHT
        );
        if (
          suggestionIndex >= 0 &&
          suggestionIndex < this.filteredSuggestions.length
        ) {
          this.selectSuggestion(suggestionIndex);
        }
        return;
      }

      // Focus the input
      this.focus();
    } catch (error) {
      this.errorHandler.handle(error, 'click-handler');
    }
  }

  handleKeyDown(event) {
    if (this.disabled) return;

    try {
      const handler = this.keyboardHandler[event.key];
      if (handler) {
        event.preventDefault();
        handler(event);
      }
    } catch (error) {
      this.errorHandler.handle(error, 'keyboard-handler');
    }
  }

  handleKeyUp(event) {
    if (this.disabled) return;

    try {
      // Handle regular character input
      if (
        event.key.length === 1 &&
        !event.ctrlKey &&
        !event.altKey &&
        !event.metaKey
      ) {
        this.setValue(this.value + event.key);
      }
    } catch (error) {
      this.errorHandler.handle(error, 'keyup-handler');
    }
  }

  handleEnterKey() {
    if (this.selectedSuggestionIndex >= 0) {
      this.selectSuggestion(this.selectedSuggestionIndex);
    } else {
      this.performSearch();
    }
  }

  handleEscapeKey() {
    if (this.showingSuggestions) {
      this.clearSuggestions();
    } else {
      this.clear();
    }
  }

  handleTabKey(event) {
    if (this.showingSuggestions && this.selectedSuggestionIndex >= 0) {
      event.preventDefault();
      this.selectSuggestion(this.selectedSuggestionIndex);
    }
  }

  handleBackspace() {
    if (this.value.length > 0) {
      this.setValue(this.value.slice(0, -1));
    }
  }

  handleDelete() {
    // For now, same as backspace - could be enhanced for cursor position
    this.handleBackspace();
  }

  handleFocus() {
    this.isFocused = true;
    this.updateSuggestions();
    this.emit('focus');
  }

  handleBlur() {
    // Delay hiding suggestions to allow for clicks
    setTimeout(() => {
      this.isFocused = false;
      this.clearSuggestions();
      this.emit('blur');
    }, INPUT_UTILITY_CONSTANTS.SEARCHBOX_SUGGESTION_ANIMATION_DELAY);
  }

  handleFocusIn() {
    this.isFocused = true;
    this.clearRenderCache();
  }

  handleFocusOut() {
    this.isFocused = false;
    this.clearRenderCache();
  }

  // Enhanced rendering with theme support
  renderSelf(renderer) {
    if (renderer.type !== 'canvas') return;

    try {
      this.performanceMonitor.startMeasurement('render');

      this.renderInputField(renderer);

      if (this.showingSuggestions) {
        this.renderSuggestions(renderer);
      }

      this.performanceMonitor.endMeasurement('render');
    } catch (error) {
      this.errorHandler.handle(error, 'render');
    }
  }

  renderInputField(renderer) {
    // Background with theme support
    const bgColor = this.disabled
      ? ComponentTheme.getColor('backgroundDisabled', this.theme)
      : ComponentTheme.getColor('background', this.theme);

    renderer.fillStyle = bgColor;
    renderer.fillRect(0, 0, this.width, this.height);

    // Border with theme support and focus state
    const borderColor = this.isFocused
      ? ComponentTheme.getColor('focus', this.theme)
      : ComponentTheme.getColor('border', this.theme);

    renderer.strokeStyle = borderColor;
    renderer.lineWidth = this.isFocused ? 2 : 1;
    renderer.strokeRect(0, 0, this.width, this.height);

    // Search icon
    this.renderSearchIcon(renderer);

    // Text content
    this.renderTextContent(renderer);

    // Clear button
    if (this.showClearButton && this.value) {
      this.renderClearButton(renderer);
    }

    // Search button
    if (this.showSearchButton) {
      this.renderSearchButton(renderer);
    }

    // Focus indicator for screen readers
    if (this.isFocused) {
      this.renderFocusIndicator(renderer);
    }

    // Cursor
    if (this.isFocused && !this.showingSuggestions) {
      this.renderCursor(renderer);
    }
  }

  renderSearchIcon(renderer) {
    const iconX = 12;
    const iconY = this.height / 2;

    renderer.fillStyle = ComponentTheme.getColor('textSecondary', this.theme);
    renderer.font = '16px Arial';
    renderer.textAlign = 'center';
    renderer.textBaseline = 'middle';
    renderer.fillText('ðŸ”', iconX, iconY);
  }

  renderTextContent(renderer) {
    const displayText = this.value || this.placeholder;
    const isPlaceholder = !this.value;
    const textColor = this.disabled
      ? ComponentTheme.getColor('disabled', this.theme)
      : isPlaceholder
        ? ComponentTheme.getColor('textSecondary', this.theme)
        : ComponentTheme.getColor('text', this.theme);

    renderer.fillStyle = textColor;
    renderer.font = isPlaceholder ? 'italic 14px Arial' : '14px Arial';
    renderer.textAlign = 'left';
    renderer.textBaseline = 'middle';

    const textX = 30; // Account for search icon
    const maxTextWidth =
      this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_BUTTON_SPACING; // Account for buttons and padding
    const truncatedText = this.truncateText(
      renderer,
      displayText,
      maxTextWidth
    );

    renderer.fillText(truncatedText, textX, this.height / 2);
  }

  renderClearButton(renderer) {
    const buttonX =
      this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_BUTTON_POSITION;
    const buttonY = this.height / 2;
    const buttonRadius = 8;

    // Button background (hover effect)
    if (this.isClearButtonHovered) {
      renderer.fillStyle = ComponentTheme.getColor('dangerHover', this.theme);
      renderer.beginPath();
      renderer.arc(buttonX, buttonY, buttonRadius, 0, Math.PI * 2);
      renderer.fill();
    }

    // Clear icon
    renderer.fillStyle = ComponentTheme.getColor('textSecondary', this.theme);
    renderer.font = '14px Arial';
    renderer.textAlign = 'center';
    renderer.textBaseline = 'middle';
    renderer.fillText('Ã—', buttonX, buttonY);
  }

  renderSearchButton(renderer) {
    const buttonWidth = 35;
    const buttonHeight =
      this.height - INPUT_UTILITY_CONSTANTS.SEARCHBOX_BUTTON_HEIGHT_OFFSET;
    const buttonX = this.width - buttonWidth - 2;
    const buttonY = 2;

    // Button background
    renderer.fillStyle = ComponentTheme.getColor('primary', this.theme);
    renderer.fillRect(buttonX, buttonY, buttonWidth, buttonHeight);

    // Button text
    renderer.fillStyle = ComponentTheme.getColor('primaryText', this.theme);
    renderer.font = '12px Arial';
    renderer.textAlign = 'center';
    renderer.textBaseline = 'middle';
    renderer.fillText(
      'Go',
      buttonX + buttonWidth / 2,
      buttonY + buttonHeight / 2
    );

    // Button border
    renderer.strokeStyle = ComponentTheme.getColor('primaryBorder', this.theme);
    renderer.lineWidth = 1;
    renderer.strokeRect(buttonX, buttonY, buttonWidth, buttonHeight);
  }

  renderFocusIndicator(renderer) {
    renderer.strokeStyle = ComponentTheme.getColor('focus', this.theme);
    renderer.lineWidth = 2;
    renderer.setLineDash([2, 2]);
    renderer.strokeRect(
      INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_OFFSET,
      INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_OFFSET,
      this.width - INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_BORDER,
      this.height - INPUT_UTILITY_CONSTANTS.FOCUS_INDICATOR_BORDER
    );
    renderer.setLineDash([]);
  }

  renderCursor(renderer) {
    const textWidth = renderer.measureText(this.value).width;
    const cursorX =
      INPUT_UTILITY_CONSTANTS.SEARCHBOX_SEARCH_ICON_OFFSET + textWidth; // Account for search icon

    // Animated cursor
    const time = Date.now();
    const opacity =
      Math.sin(
        time * INPUT_UTILITY_CONSTANTS.SEARCHBOX_CURSOR_BLINK_FREQUENCY
      ) *
        INPUT_UTILITY_CONSTANTS.SEARCHBOX_CURSOR_OPACITY_FACTOR +
      INPUT_UTILITY_CONSTANTS.SEARCHBOX_CURSOR_OPACITY_BASE;

    renderer.strokeStyle = `rgba(${this.theme === 'dark' ? '255,255,255' : '0,0,0'}, ${opacity})`;
    renderer.lineWidth = 1;
    renderer.beginPath();
    renderer.moveTo(cursorX, INPUT_UTILITY_CONSTANTS.SEARCHBOX_CURSOR_MARGIN);
    renderer.lineTo(
      cursorX,
      this.height - INPUT_UTILITY_CONSTANTS.SEARCHBOX_CURSOR_MARGIN
    );
    renderer.stroke();
  }

  renderSuggestions(renderer) {
    const startY = this.height;
    const suggestionHeight = 30;
    const totalHeight = this.filteredSuggestions.length * suggestionHeight;

    // Suggestions container background
    renderer.fillStyle = ComponentTheme.getColor('background', this.theme);
    renderer.fillRect(0, startY, this.width, totalHeight);

    // Suggestions container border
    renderer.strokeStyle = ComponentTheme.getColor('border', this.theme);
    renderer.lineWidth = 1;
    renderer.strokeRect(0, startY, this.width, totalHeight);

    // Individual suggestions
    this.filteredSuggestions.forEach((suggestion, index) => {
      this.renderSuggestion(
        renderer,
        suggestion,
        index,
        startY + index * suggestionHeight,
        suggestionHeight
      );
    });
  }

  renderSuggestion(renderer, suggestion, index, y, height) {
    const isSelected = index === this.selectedSuggestionIndex;

    // Highlight selected suggestion
    if (isSelected) {
      renderer.fillStyle = ComponentTheme.getColor('primaryHover', this.theme);
      renderer.fillRect(0, y, this.width, height);
    }

    // Suggestion text with highlighting
    if (this.highlightMatches && this.value) {
      this.renderHighlightedText(
        renderer,
        suggestion,
        this.value,
        INPUT_UTILITY_CONSTANTS.SEARCHBOX_SUGGESTION_ICON_OFFSET,
        y + height / 2
      );
    } else {
      renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
      renderer.font = '14px Arial';
      renderer.textAlign = 'left';
      renderer.textBaseline = 'middle';

      const maxWidth = this.width - INPUT_UTILITY_CONSTANTS.ACCORDION_PADDING;
      const truncatedSuggestion = this.truncateText(
        renderer,
        suggestion,
        maxWidth
      );
      renderer.fillText(
        truncatedSuggestion,
        INPUT_UTILITY_CONSTANTS.ACCORDION_ICON_MARGIN,
        y + height / 2
      );
    }

    // Selection indicator
    if (isSelected) {
      renderer.fillStyle = ComponentTheme.getColor('primary', this.theme);
      renderer.font = '12px Arial';
      renderer.textAlign = 'right';
      renderer.textBaseline = 'middle';
      renderer.fillText(
        'â†©',
        this.width - INPUT_UTILITY_CONSTANTS.SEARCHBOX_SUGGESTION_ICON_OFFSET,
        y + height / 2
      );
    }

    // Separator line
    if (index < this.filteredSuggestions.length - 1) {
      renderer.strokeStyle = ComponentTheme.getColor('border', this.theme);
      renderer.lineWidth = 1;
      renderer.beginPath();
      renderer.moveTo(0, y + height);
      renderer.lineTo(this.width, y + height);
      renderer.stroke();
    }
  }

  renderHighlightedText(renderer, text, query, x, y) {
    const caseSensitiveText = this.caseSensitive ? text : text.toLowerCase();
    const caseSensitiveQuery = this.caseSensitive ? query : query.toLowerCase();
    const matchIndex = caseSensitiveText.indexOf(caseSensitiveQuery);

    renderer.font = '14px Arial';
    renderer.textAlign = 'left';
    renderer.textBaseline = 'middle';

    if (matchIndex === -1) {
      // No match, render normally
      renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
      renderer.fillText(text, x, y);
    } else {
      // Render with highlighting
      const beforeMatch = text.slice(0, matchIndex);
      const match = text.slice(matchIndex, matchIndex + query.length);
      const afterMatch = text.slice(matchIndex + query.length);

      let currentX = x;

      // Before match
      if (beforeMatch) {
        renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
        renderer.fillText(beforeMatch, currentX, y);
        currentX += renderer.measureText(beforeMatch).width;
      }

      // Highlighted match
      if (match) {
        renderer.fillStyle = ComponentTheme.getColor('primaryText', this.theme);
        const matchWidth = renderer.measureText(match).width;

        // Highlight background
        renderer.fillStyle = ComponentTheme.getColor('primary', this.theme);
        renderer.fillRect(
          currentX,
          y - INPUT_UTILITY_CONSTANTS.SEARCHBOX_HIGHLIGHT_Y_OFFSET,
          matchWidth,
          INPUT_UTILITY_CONSTANTS.SEARCHBOX_HIGHLIGHT_HEIGHT
        );

        // Match text
        renderer.fillStyle = ComponentTheme.getColor('primaryText', this.theme);
        renderer.fillText(match, currentX, y);
        currentX += matchWidth;
      }

      // After match
      if (afterMatch) {
        renderer.fillStyle = ComponentTheme.getColor('text', this.theme);
        renderer.fillText(afterMatch, currentX, y);
      }
    }
  }

  truncateText(renderer, text, maxWidth) {
    const metrics = renderer.measureText(text);
    if (metrics.width <= maxWidth) {
      return text;
    }

    const ellipsis = '...';

    let truncated = text;
    while (
      renderer.measureText(truncated + ellipsis).width > maxWidth &&
      truncated.length > 0
    ) {
      truncated = truncated.slice(0, -1);
    }

    return truncated + ellipsis;
  }

  // Performance optimization methods
  clearRenderCache() {
    this.renderCache.clear();
  }

  throttle(func, limit) {
    let inThrottle;
    return function (...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
  }

  // Public API with enhanced error handling
  getSuggestions() {
    return [...this.suggestions];
  }

  setSuggestions(suggestions) {
    if (!Array.isArray(suggestions)) {
      throw new ComponentError('Suggestions must be an array', 'SearchBox');
    }

    this.suggestions = suggestions.map(s => String(s));
    this.updateSuggestions();
    this.emit('suggestionsChanged', { suggestions: this.suggestions });
  }

  addSuggestion(suggestion) {
    const suggestionStr = String(suggestion);
    if (!this.suggestions.includes(suggestionStr)) {
      this.suggestions.push(suggestionStr);
      this.updateSuggestions();
      this.emit('suggestionAdded', { suggestion: suggestionStr });
    }
  }

  removeSuggestion(suggestion) {
    const index = this.suggestions.indexOf(suggestion);
    if (index >= 0) {
      this.suggestions.splice(index, 1);
      this.updateSuggestions();
      this.emit('suggestionRemoved', { suggestion, index });
    }
  }

  getSearchHistory() {
    return [...this.searchHistory];
  }

  clearSearchHistory() {
    this.searchHistory = [];
    this.emit('historyCleared');
  }

  setPlaceholder(placeholder) {
    this.placeholder = String(placeholder || '');
    this.clearRenderCache();
    this.emit('placeholderChanged', { placeholder: this.placeholder });
  }

  enable() {
    this.disabled = false;
    this.setAttribute('tabindex', '0');
    this.clearRenderCache();
    this.emit('enabled');
  }

  disable() {
    this.disabled = true;
    this.setAttribute('tabindex', '-1');
    this.clearSuggestions();
    this.clearRenderCache();
    this.emit('disabled');
  }

  reset() {
    this.value = '';
    this.clearSuggestions();
    this.clearSearchHistory();
    this.selectedSuggestionIndex = -1;
    this.clearRenderCache();
    this.emit('reset');
  }

  // Cleanup and memory management
  destroy() {
    try {
      // Cancel any pending searches
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
        this.debounceTimer = null;
      }

      // Clean up resize observer
      if (this.resizeObserver) {
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      }

      // Remove announcer from DOM
      if (this.announcer && this.announcer.parentNode) {
        this.announcer.parentNode.removeChild(this.announcer);
      }

      // Clear caches and state
      this.clearRenderCache();
      this.clearSuggestions();
      this.clearSearchHistory();

      // Call parent cleanup
      super.destroy?.();
      this.emit('destroyed');
    } catch (error) {
      logger.error('Error during SearchBox cleanup:', error);
    }
  }
}

// Export all components
export { NumberInput, Drawer, SearchBox };

export default {
  NumberInput,
  Drawer,
  SearchBox,
};
