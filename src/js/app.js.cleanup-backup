/**
 * Copyright 2025 Armando Sori
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Main Application - SimulateAI Educational Platform
 * Initializes the platform and manages the overall application state
 */

// Import core modules
import EthicsSimulation from './core/simulation.js';
import AccessibilityManager from './core/accessibility.js';
import AnimationManager from './core/animation-manager.js';
import EducatorToolkit from './core/educator-toolkit.js';
import DigitalScienceLab from './core/digital-science-lab.js';
import ScenarioGenerator from './core/scenario-generator.js';

// Import utilities
import { userPreferences, userProgress } from './utils/simple-storage.js';
import { simpleAnalytics } from './utils/simple-analytics.js';
import Helpers from './utils/helpers.js';
import canvasManager from './utils/canvas-manager.js';
import logger from './utils/logger.js';
// import { initializeHorizontalScroll, preventPageScrollSnap } from './utils/horizontal-scroll.js';

// Import enhanced objects (loaded dynamically as needed)
// import { EthicsMeter, InteractiveButton, InteractiveSlider } from './objects/enhanced-objects.js';

// Import new modal components
import PreLaunchModal from './components/pre-launch-modal.js';
import { EnhancedSimulationModal } from './components/enhanced-simulation-modal.js';
import { PostSimulationModal } from './components/post-simulation-modal.js';
import ModalFooterManager from './components/modal-footer-manager.js';
import CategoryGrid from './components/category-grid.js';
import RadarChart from './components/radar-chart.js';
import OnboardingTour from './components/onboarding-tour.js';
import { getAllCategories, getCategoryScenarios } from '../data/categories.js';

// Constants for app configuration
const APP_CONSTANTS = {
  VIEWPORT: {
    MOBILE_BREAKPOINT: 767,
  },
  DEFAULTS: {
    SCORE_VALUE: 0.5,
    SLIDER_VALUE: 50,
    METER_VALUE: 0.5,
    ETHICS_METER_VALUE: 50,
  },
  FEEDBACK: {
    EXCELLENT_THRESHOLD: 70,
    GOOD_THRESHOLD: 50,
  },
  TIMING: {
    ANIMATION_DELAY: 300,
    NOTIFICATION_DURATION: 4000,
    STAGGER_DELAY: 300,
    QUICK_DELAY: 50,
  },
};

// Debug utility to replace console statements
const AppDebug = {
  log: (message, data = null) => {
    if (window.DEBUG_MODE || localStorage.getItem('debug') === 'true') {
      // eslint-disable-next-line no-console
      console.log(`[App] ${message}`, data || '');
    }
  },
  warn: (message, data = null) => {
    if (window.DEBUG_MODE || localStorage.getItem('debug') === 'true') {
      // eslint-disable-next-line no-console
      console.warn(`[App] ${message}`, data || '');
    }
  },
  error: (message, error = null) => {
    // Always show errors
    // eslint-disable-next-line no-console
    console.error(`[App] ${message}`, error || '');
  },
};

class AIEthicsApp {
  constructor() {
    // Version identifier for debugging
    this.version = 'v2.0.1-context-fixes';
    logger.info('App', `Initializing AIEthicsApp ${this.version}`);

    this.currentSimulation = null;
    this.engine = null;
    this.visualEngine = null;
    this.simulations = new Map();
    this.isInitialized = false;
    this.heroDemo = null;

    // Modernized managers
    this.accessibilityManager = null;
    this.animationManager = null;

    // Core educational modules
    this.educatorToolkit = null;
    this.digitalScienceLab = null;
    this.scenarioGenerator = null;

    // Enhanced objects for UI
    this.ethicsMeters = new Map();
    this.interactiveButtons = new Map();
    this.simulationSliders = new Map();

    // Canvas management IDs
    this.currentSimulationCanvasId = null;
    this.ethicsMetersCanvasId = null;
    this.interactiveButtonsCanvasId = null;
    this.simulationSlidersCanvasId = null;
    this.heroDemoCanvasId = null;

    // UI elements
    this.modal = null;
    this.enhancedModal = null;
    this.simulationContainer = null;
    this.categoriesGrid = null;
    this.lastFocusedElement = null; // For focus restoration

    // Theme and preferences
    this.currentTheme = 'light';
    this.preferences = {
      reducedMotion: false,
      highContrast: false,
      largeText: false,
    };

    // Error handling
    this.errorBoundary = null;
    this.lastError = null;

    // Available ethics categories (each containing multiple scenarios)
    // NOTE: These are thematic categories, not individual scenarios
    this.availableSimulations = [
      {
        id: 'bias-fairness',
        title: 'AI Ethics Explorer',
        description:
          'Explore real-world AI scenarios and see how different choices affect various groups in society. No right answers - just learning through cause and effect.',
        difficulty: 'beginner',
        duration: 1200, // 20 minutes
        thumbnail: 'src/assets/images/bias-fairness-thumb.svg',
        tags: ['ethics', 'fairness', 'education', 'scenarios', 'open-ended'],
        useCanvas: false, // HTML-only simulation, no canvas needed
        renderMode: 'html',
      },
      {
        id: 'consent-transparency',
        title: 'Consent & Transparency',
        description:
          'Learn about informed consent and the importance of transparency in AI systems.',
        difficulty: 'beginner',
        duration: 480, // 8 minutes
        thumbnail: 'src/assets/images/consent-transparency-thumb.svg',
        tags: ['consent', 'transparency', 'privacy', 'communication'],
      },
      {
        id: 'autonomy-oversight',
        title: 'Autonomy & Oversight',
        description:
          'Balance AI autonomy with human oversight in critical decision-making scenarios.',
        difficulty: 'intermediate',
        duration: 720, // 12 minutes
        thumbnail: 'src/assets/images/autonomy-oversight-thumb.svg',
        tags: ['autonomy', 'oversight', 'control', 'responsibility'],
      },
      {
        id: 'misinformation-trust',
        title: 'Misinformation & Trust',
        description:
          'Combat misinformation and build trustworthy AI communication systems.',
        difficulty: 'advanced',
        duration: 900, // 15 minutes
        thumbnail: 'src/assets/images/misinformation-trust-thumb.svg',
        tags: ['misinformation', 'trust', 'communication', 'verification'],
      },
    ];
  }
  async init() {
    if (this.isInitialized) return;

    try {
      // IMMEDIATE scroll reset - before any other operations
      window.scrollTo(0, 0);
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;

      // Prevent automatic scroll restoration on page refresh
      if ('scrollRestoration' in history) {
        history.scrollRestoration = 'manual';
      }

      // Force scroll to top again after a short delay to override any browser restoration
      setTimeout(() => {
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
      }, 10);

      // Initialize theme detection first
      this.initializeTheme();

      // Initialize error handling
      this.initializeErrorHandling();

      // Initialize core systems
      await this.initializeSystems();

      // Setup UI
      this.setupUI();

      // Load simulations
      await this.loadSimulations();

      // Setup event listeners
      this.setupEventListeners();

      // Initialize accessibility
      this.setupAccessibility();

      // Render initial state
      this.render();

      // Initialize hero demo
      await this.initializeHeroDemo();

      // Initialize enhanced objects (after visual engine is set up)
      await this.initializeEnhancedObjects();

      // Initialize modal footer management
      this.initializeModalFooterManager();

      // Initialize ethics radar demo
      await this.initializeEthicsRadarDemo();

      // Prevent page scroll snap issues
      // preventPageScrollSnap();

      // Initialize horizontal scroll functionality
      // initializeHorizontalScroll();

      // Initialize scroll reveal header
      this.initializeScrollRevealHeader();

      this.isInitialized = true;
      AppDebug.log(
        'AI Ethics App initialized successfully with modernized infrastructure'
      );

      // Initialize onboarding tour for first-time users
      this.onboardingTour = new OnboardingTour();

      // Auto-start tour for first-time visitors
      this.checkAndStartOnboardingTour();

      // Track initialization
      simpleAnalytics.trackEvent('app_initialized', {
        simulations_available: this.availableSimulations.length,
        browser: Helpers.getBrowserInfo().browser,
        device: Helpers.getDeviceType(),
        theme: this.currentTheme,
        accessibility_enabled:
          this.preferences.highContrast || this.preferences.largeText,
      });
    } catch (error) {
      AppDebug.error('Failed to initialize app:', error);
      this.handleError(
        error,
        'Failed to initialize the application. Please refresh the page.'
      );
    }
  }

  /**
   * Initialize theme detection and monitoring
   */
  initializeTheme() {
    // Detect system preferences
    const prefersReducedMotion = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    const prefersHighContrast = window.matchMedia?.(
      '(prefers-contrast: high)'
    ).matches;

    // Get saved user preferences (they override system preferences)
    const savedPreferences = userPreferences.getAccessibilitySettings();

    // Use saved preferences if they exist, otherwise use system preferences
    this.preferences = {
      reducedMotion:
        savedPreferences.reducedMotion !== undefined
          ? savedPreferences.reducedMotion
          : prefersReducedMotion,
      highContrast:
        savedPreferences.highContrast !== undefined
          ? savedPreferences.highContrast
          : prefersHighContrast,
      largeText: savedPreferences.largeText || false, // Default to false
    };

    this.currentTheme = this.preferences.highContrast
      ? 'high-contrast'
      : 'light';

    // Apply initial theme
    this.applyTheme();

    // Monitor theme changes
    this.setupThemeMonitoring();

    AppDebug.log('Theme initialized:', this.currentTheme, this.preferences);
  }

  /**
   * Initialize scroll reveal header functionality
   */
  initializeScrollRevealHeader() {
    const header = document.querySelector('.header');
    if (!header) return;

    let lastScrollY = window.scrollY;

    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      // Don't hide header at the very top of the page
      if (currentScrollY <= 10) {
        header.classList.remove('header-hidden');
        header.classList.add('header-visible');
      } else {
        // Hide header when scrolling down, show when scrolling up
        if (currentScrollY > lastScrollY && currentScrollY > 100) {
          // Scrolling down - hide header
          header.classList.add('header-hidden');
          header.classList.remove('header-visible');
        } else if (currentScrollY < lastScrollY) {
          // Scrolling up - show header
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
      }

      lastScrollY = currentScrollY;
    };

    // Throttle scroll events for better performance
    let ticking = false;
    const throttledHandleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    // Initialize header as visible
    header.classList.add('header-visible');

    AppDebug.log('Scroll reveal header initialized');
  }

  /**
   * Setup theme change monitoring
   */
  setupThemeMonitoring() {
    const reducedMotionQuery = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    );
    const highContrastQuery = window.matchMedia?.('(prefers-contrast: high)');

    const handleThemeChange = () => {
      // Get current saved preferences to check which ones are user-set
      const savedPreferences = userPreferences.getAccessibilitySettings();

      // Only update preferences that haven't been explicitly set by the user
      const newPreferences = { ...this.preferences };

      // Update system-based preferences only if user hasn't overridden them
      if (savedPreferences.reducedMotion === undefined) {
        newPreferences.reducedMotion = reducedMotionQuery?.matches || false;
      }
      if (savedPreferences.highContrast === undefined) {
        newPreferences.highContrast = highContrastQuery?.matches || false;
      }
      // largeText is always user-controlled, so never auto-update it

      if (JSON.stringify(newPreferences) !== JSON.stringify(this.preferences)) {
        this.preferences = newPreferences;
        this.currentTheme = newPreferences.highContrast
          ? 'high-contrast'
          : 'light';
        this.applyTheme();
        this.announceThemeChange();

        AppDebug.log(
          'System theme changed, updated non-user-set preferences:',
          newPreferences
        );
      }
    };

    reducedMotionQuery?.addEventListener?.('change', handleThemeChange);
    highContrastQuery?.addEventListener?.('change', handleThemeChange);
  }

  /**
   * Apply current theme to the application
   */
  applyTheme() {
    const { body } = document;

    // Remove existing theme classes
    body.classList.remove('high-contrast', 'reduced-motion', 'large-text');

    // Apply current theme classes
    if (this.preferences.highContrast) body.classList.add('high-contrast');
    if (this.preferences.reducedMotion) body.classList.add('reduced-motion');
    if (this.preferences.largeText) body.classList.add('large-text');

    // Update button states (aria-pressed attributes)
    this.updateButtonStates();

    // Update theme color meta tag
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      const themeColor = '#1a73e8'; // Always use light theme color
      themeColorMeta.setAttribute('content', themeColor);
    }

    // Update managers if they exist
    if (this.animationManager) {
      // Update the animation manager theme when preferences change
      this.animationManager.updateAnimationDefaults();
    }

    if (this.accessibilityManager) {
      this.accessibilityManager.updateTheme(this.preferences);
    }
  }

  /**
   * Update accessibility button states
   */
  updateButtonStates() {
    const highContrastBtn = document.getElementById('toggle-high-contrast');
    const largeTextBtn = document.getElementById('toggle-large-text');
    const reducedMotionBtn = document.getElementById('toggle-reduced-motion');

    if (highContrastBtn) {
      highContrastBtn.setAttribute(
        'aria-pressed',
        this.preferences.highContrast.toString()
      );
    }
    if (largeTextBtn) {
      largeTextBtn.setAttribute(
        'aria-pressed',
        this.preferences.largeText.toString()
      );
    }
    if (reducedMotionBtn) {
      reducedMotionBtn.setAttribute(
        'aria-pressed',
        this.preferences.reducedMotion.toString()
      );
    }
  }

  /**
   * Announce theme changes for accessibility
   */
  announceThemeChange() {
    const announcement = `Theme changed to ${this.currentTheme.replace('-', ' ')} mode`;

    if (this.accessibilityManager) {
      this.accessibilityManager.announce(announcement);
    } else {
      // Fallback announcement
      const liveRegion = document.getElementById('aria-live-polite');
      if (liveRegion) {
        liveRegion.textContent = announcement;
      }
    }
  }

  /**
   * Initialize error handling and recovery
   */
  initializeErrorHandling() {
    // Create error boundary element
    this.errorBoundary = document.getElementById('error-boundary');

    // Global error handlers
    window.addEventListener('error', event => {
      this.handleError(event.error, 'A JavaScript error occurred');
    });

    window.addEventListener('unhandledrejection', event => {
      this.handleError(event.reason, 'An unhandled promise rejection occurred');
    });

    AppDebug.log('Error handling initialized');
  }

  /**
   * Enhanced error handling with recovery options
   */
  handleError(error, userMessage = 'An unexpected error occurred') {
    this.lastError = error;
    AppDebug.error('App Error:', error);

    // Track error for analytics
    simpleAnalytics.trackEvent('app_error', {
      error_message: error.message || String(error),
      error_stack: error.stack,
      user_agent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    });

    // Show error to user
    this.showError(userMessage);

    // Announce error for accessibility
    if (this.accessibilityManager) {
      this.accessibilityManager.announce(`Error: ${userMessage}`, 'assertive');
    }
  }

  /**
   * Show error in error boundary
   */
  showError(message, isRecoverable = true) {
    if (!this.errorBoundary) {
      // Fallback to alert if no error boundary
      alert(message);
      return;
    }

    const errorContent = this.errorBoundary.querySelector('.error-content');
    if (errorContent) {
      const messageEl = errorContent.querySelector('.error-message');
      const retryBtn = errorContent.querySelector('#retry-action');
      const reportBtn = errorContent.querySelector('#report-error');

      if (messageEl) messageEl.textContent = message;

      // Setup retry functionality
      if (retryBtn && isRecoverable) {
        retryBtn.style.display = 'inline-block';
        retryBtn.onclick = () => {
          this.hideError();
          // Attempt to recover by reinitializing
          if (!this.isInitialized) {
            this.init();
          }
        };
      } else if (retryBtn) {
        retryBtn.style.display = 'none';
      }

      // Setup error reporting
      if (reportBtn) {
        reportBtn.onclick = () => {
          this.reportError();
        };
      }
    }

    this.errorBoundary.setAttribute('aria-hidden', 'false');
    this.errorBoundary.style.display = 'flex';
  }

  /**
   * Hide error boundary
   */
  hideError() {
    if (this.errorBoundary) {
      this.errorBoundary.setAttribute('aria-hidden', 'true');
      this.errorBoundary.style.display = 'none';
    }
  }

  /**
   * Report error to analytics/support
   */
  reportError() {
    if (this.lastError) {
      const errorReport = {
        message: this.lastError.message || String(this.lastError),
        stack: this.lastError.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: new Date().toISOString(),
        appState: {
          initialized: this.isInitialized,
          currentSimulation: this.currentSimulation?.id,
          theme: this.currentTheme,
        },
      };

      // Send to analytics
      simpleAnalytics.trackEvent('error_reported', errorReport);

      // Show confirmation
      alert(
        'Error report sent. Thank you for helping us improve the application.'
      );
    }
  }

  async initializeSystems() {
    try {
      // Initialize animation manager with theme preferences
      this.animationManager = new AnimationManager({
        enableAnimations: !this.preferences.reducedMotion,
        reducedMotion: this.preferences.reducedMotion,
        performanceMode: this.preferences.reducedMotion
          ? 'compatibility'
          : 'balanced',
      });

      // Initialize accessibility manager with current preferences
      this.accessibilityManager = new AccessibilityManager(document.body, {
        theme: this.currentTheme,
        preferences: this.preferences,
      });

      // Initialize core educational modules
      await this.initializeCoreModules();

      // Visual Engine will be initialized later when we have canvas elements
      // Just store the configuration for now
      this.visualEngineConfig = {
        renderMode: 'canvas',
        accessibility: true,
        highPerformance: !this.preferences.reducedMotion,
        debug: false,
        highContrast: this.preferences.highContrast,
        reducedMotion: this.preferences.reducedMotion,
      };

      // Systems are already initialized via their modules
      // Simple analytics auto-initializes
      AppDebug.log('Core systems initialized with modernized infrastructure');
    } catch (error) {
      AppDebug.error('Failed to initialize systems:', error);
      throw error;
    }
  }

  /**
   * Initialize core educational modules
   */
  async initializeCoreModules() {
    try {
      // Initialize Educator Toolkit
      this.educatorToolkit = new EducatorToolkit();
      AppDebug.log('Educator Toolkit initialized');

      // Initialize Digital Science Lab
      this.digitalScienceLab = new DigitalScienceLab();
      AppDebug.log('Digital Science Lab initialized');

      // Initialize Scenario Generator
      this.scenarioGenerator = new ScenarioGenerator();
      AppDebug.log('Scenario Generator initialized');

      // Connect the modules for integrated functionality
      this.connectEducationalModules();
    } catch (error) {
      AppDebug.error('Failed to initialize core educational modules:', error);
      throw error;
    }
  }

  /**
   * Connect educational modules for integrated functionality
   */
  connectEducationalModules() {
    // Connect scenario generator to educator toolkit for assessment alignment
    if (this.educatorToolkit && this.scenarioGenerator) {
      this.educatorToolkit.setScenarioGenerator(this.scenarioGenerator);
    }

    // Connect digital science lab to both toolkit and generator
    if (this.digitalScienceLab) {
      if (this.educatorToolkit) {
        this.digitalScienceLab.setEducatorToolkit(this.educatorToolkit);
      }
      if (this.scenarioGenerator) {
        this.digitalScienceLab.setScenarioGenerator(this.scenarioGenerator);
      }
    }

    AppDebug.log('Educational modules connected successfully');
  }

  /**
   * Connect core educational modules to a simulation instance
   * @param {Object} simulation - The simulation instance
   * @param {Object} config - The simulation configuration
   */
  connectModulesToSimulation(simulation, config) {
    try {
      // Connect Educator Toolkit
      if (this.educatorToolkit && simulation) {
        simulation.educatorToolkit = this.educatorToolkit;

        // Get curriculum alignment for this simulation
        const curriculumAlignment = this.educatorToolkit.getCurriculumAlignment(
          config.tags || []
        );
        if (curriculumAlignment) {
          simulation.curriculumAlignment = curriculumAlignment;
        }

        // Get assessment tools for this simulation
        const assessmentTools = this.educatorToolkit.getAssessmentTools(
          config.difficulty
        );
        if (assessmentTools) {
          simulation.assessmentTools = assessmentTools;
        }
      }

      // Connect Digital Science Lab
      if (this.digitalScienceLab && simulation) {
        simulation.digitalScienceLab = this.digitalScienceLab;

        // Get relevant lab stations for this simulation
        const relevantStations = this.digitalScienceLab.getRelevantStations(
          config.tags || []
        );
        if (relevantStations) {
          simulation.labStations = relevantStations;
        }
      }

      // Connect Scenario Generator
      if (this.scenarioGenerator && simulation) {
        simulation.scenarioGenerator = this.scenarioGenerator;

        // If this simulation can use generated scenarios, provide them
        if (simulation.supportsGeneratedScenarios) {
          const generatedScenarios = this.scenarioGenerator.generateScenarios(
            config.tags?.[0] || 'general',
            config.difficulty || 'beginner'
          );
          if (generatedScenarios) {
            simulation.generatedScenarios = generatedScenarios;
          }
        }
      }

      AppDebug.log(
        `Educational modules connected to simulation: ${simulation.id || 'unknown'}`
      );
    } catch (error) {
      AppDebug.error(
        'Failed to connect educational modules to simulation:',
        error
      );
      // Non-critical error - simulation can still function without full integration
    }
  }

  setupUI() {
    // Get key UI elements
    this.modal = document.getElementById('simulation-modal');
    this.simulationContainer = document.getElementById('simulation-container');
    this.categoriesGrid = document.querySelector(
      '.categories-grid, .simulations-grid'
    );
    this.loading = document.getElementById('loading');

    if (!this.categoriesGrid) {
      AppDebug.error('Categories grid not found');
      return;
    }

    // Initialize CategoryGrid
    this.initializeCategoryGrid();
  }

  /**
   * Initialize the new category grid system
   */
  initializeCategoryGrid() {
    try {
      this.categoryGrid = new CategoryGrid();
      AppDebug.log('Category grid initialized successfully');
    } catch (error) {
      AppDebug.error('Failed to initialize category grid:', error);
      // Fallback to legacy simulation loading if category grid fails
      this.loadLegacySimulations();
    }
  }

  /**
   * Fallback method for legacy simulation loading
   */
  loadLegacySimulations() {
    AppDebug.log('Loading legacy simulation cards as fallback');
    // This will be populated with existing simulation loading logic if needed
    // For now, just log that we're in fallback mode
  }

  async loadSimulations() {
    // Simulations are loaded dynamically in createSimulationInstance()
    // Store available simulation configs in the simulations Map
    this.availableSimulations.forEach(simConfig => {
      this.simulations.set(simConfig.id, simConfig);
    });
  }

  /**
   * Initialize hero demo component
   * Currently using radar chart demo instead of HeroDemo class
   */
  async initializeHeroDemo() {
    // The HeroDemo class is designed for a different hero layout
    // that's not currently implemented. The radar chart demo is working fine.
    logger.info(
      'App',
      'Hero demo: Using radar chart demo instead of HeroDemo class'
    );
  }

  /**
   * Initialize enhanced objects (visual components)
   */
  async initializeEnhancedObjects() {
    try {
      // Enhanced objects are loaded dynamically when needed
      // This method is kept for future initialization if needed
      logger.info('App', 'Enhanced objects system ready for dynamic loading');
    } catch (error) {
      logger.error('Failed to initialize enhanced objects:', error);
      // Non-critical error - app can continue with basic functionality
    }
  }

  /**
   * Initialize modal footer management system
   */
  initializeModalFooterManager() {
    try {
      // Initialize the modal footer manager
      this.modalFooterManager = new ModalFooterManager();

      // Store reference for cleanup
      this.modalFooterManager.app = this;

      logger.info('App', 'Modal footer manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize modal footer manager:', error);
      // Non-critical error - modals will still work with basic functionality
    }
  }

  /**
   * Initialize ethics radar demo system
   */
  async initializeEthicsRadarDemo() {
    try {
      // Only initialize if the hero demo container exists
      const demoContainer = document.getElementById('hero-ethics-chart');
      if (demoContainer) {
        // Initialize the ethics radar demo
        ethicsDemo = new EthicsRadarDemo();

        logger.info('App', 'Ethics radar demo initialized successfully');
      } else {
        logger.warn(
          'Hero ethics chart container not found, skipping radar demo initialization'
        );
      }
    } catch (error) {
      logger.error('Failed to initialize ethics radar demo:', error);
      // Non-critical error - the demo is optional
    }
  }

  setupEventListeners() {
    // Mobile navigation functionality
    this.setupMobileNavigation();

    // Surprise Me functionality
    this.setupSurpriseMe();

    // Tour functionality
    this.setupTourButton();

    // Hero section buttons
    const startLearningBtn = document.getElementById('start-learning');

    if (startLearningBtn) {
      startLearningBtn.addEventListener('click', () => {
        this.scrollToSimulations();
      });
    }

    // Debug: Test scenario modal button
    const testScenarioBtn = document.getElementById('test-scenario-modal');
    if (testScenarioBtn) {
      testScenarioBtn.addEventListener('click', () => {
        this.testScenarioModal();
      });
    }

    // Modal controls
    if (this.modal) {
      const closeBtn = this.modal.querySelector('.modal-close');
      const resetBtn = document.getElementById('reset-simulation');
      const nextBtn = document.getElementById('next-scenario');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeSimulation());

        // Add focus trapping to the modal
        this.modal.addEventListener('keydown', e => {
          if (e.key === 'Tab') {
            this.trapFocusInModal(e);
          }
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetCurrentSimulation());
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => this.nextScenario());
      }

      // Close modal on backdrop click
      this.modal.addEventListener('click', e => {
        if (e.target === this.modal) {
          this.closeSimulation();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !this.modal.hasAttribute('aria-hidden')) {
          this.closeSimulation();
        }
      });
    }

    // Enhanced simulation card buttons (delegated event handling)
    document.addEventListener('click', e => {
      if (e.target.classList.contains('enhanced-sim-button')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Learning Lab button - go through pre-launch modal
          this.startSimulation.call(this, simulationId);
        }
      } else if (e.target.classList.contains('simulation-quick-start-btn')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Quick start button - skip pre-launch modal
          this.launchSimulationDirect.call(this, simulationId);
        }
      }
    });
  }

  /**
   * Check if this is a first-time visit and start onboarding tour
   */
  checkAndStartOnboardingTour() {
    if (!this.onboardingTour) {
      return;
    }

    // Check if user has completed the tour
    if (this.onboardingTour.hasCompletedTour()) {
      AppDebug.log('User has already completed onboarding tour');
      return;
    }

    // Check if this is a first-time visit
    if (this.onboardingTour.isFirstTimeVisit()) {
      AppDebug.log('First-time visit detected, starting onboarding tour');
      // Small delay to ensure all UI is ready
      setTimeout(() => {
        this.onboardingTour.startTour(1);
      }, 500);
    }
  }

  /**
   * Initialize theme detection and monitoring
   */
  initializeTheme() {
    // Detect system preferences
    const prefersReducedMotion = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    const prefersHighContrast = window.matchMedia?.(
      '(prefers-contrast: high)'
    ).matches;

    // Get saved user preferences (they override system preferences)
    const savedPreferences = userPreferences.getAccessibilitySettings();

    // Use saved preferences if they exist, otherwise use system preferences
    this.preferences = {
      reducedMotion:
        savedPreferences.reducedMotion !== undefined
          ? savedPreferences.reducedMotion
          : prefersReducedMotion,
      highContrast:
        savedPreferences.highContrast !== undefined
          ? savedPreferences.highContrast
          : prefersHighContrast,
      largeText: savedPreferences.largeText || false, // Default to false
    };

    this.currentTheme = this.preferences.highContrast
      ? 'high-contrast'
      : 'light';

    // Apply initial theme
    this.applyTheme();

    // Monitor theme changes
    this.setupThemeMonitoring();

    AppDebug.log('Theme initialized:', this.currentTheme, this.preferences);
  }

  /**
   * Initialize scroll reveal header functionality
   */
  initializeScrollRevealHeader() {
    const header = document.querySelector('.header');
    if (!header) return;

    let lastScrollY = window.scrollY;

    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      // Don't hide header at the very top of the page
      if (currentScrollY <= 10) {
        header.classList.remove('header-hidden');
        header.classList.add('header-visible');
      } else {
        // Hide header when scrolling down, show when scrolling up
        if (currentScrollY > lastScrollY && currentScrollY > 100) {
          // Scrolling down - hide header
          header.classList.add('header-hidden');
          header.classList.remove('header-visible');
        } else if (currentScrollY < lastScrollY) {
          // Scrolling up - show header
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
      }

      lastScrollY = currentScrollY;
    };

    // Throttle scroll events for better performance
    let ticking = false;
    const throttledHandleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    // Initialize header as visible
    header.classList.add('header-visible');

    AppDebug.log('Scroll reveal header initialized');
  }

  /**
   * Setup theme change monitoring
   */
  setupThemeMonitoring() {
    const reducedMotionQuery = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    );
    const highContrastQuery = window.matchMedia?.('(prefers-contrast: high)');

    const handleThemeChange = () => {
      // Get current saved preferences to check which ones are user-set
      const savedPreferences = userPreferences.getAccessibilitySettings();

      // Only update preferences that haven't been explicitly set by the user
      const newPreferences = { ...this.preferences };

      // Update system-based preferences only if user hasn't overridden them
      if (savedPreferences.reducedMotion === undefined) {
        newPreferences.reducedMotion = reducedMotionQuery?.matches || false;
      }
      if (savedPreferences.highContrast === undefined) {
        newPreferences.highContrast = highContrastQuery?.matches || false;
      }
      // largeText is always user-controlled, so never auto-update it

      if (JSON.stringify(newPreferences) !== JSON.stringify(this.preferences)) {
        this.preferences = newPreferences;
        this.currentTheme = newPreferences.highContrast
          ? 'high-contrast'
          : 'light';
        this.applyTheme();
        this.announceThemeChange();

        AppDebug.log(
          'System theme changed, updated non-user-set preferences:',
          newPreferences
        );
      }
    };

    reducedMotionQuery?.addEventListener?.('change', handleThemeChange);
    highContrastQuery?.addEventListener?.('change', handleThemeChange);
  }

  /**
   * Apply current theme to the application
   */
  applyTheme() {
    const { body } = document;

    // Remove existing theme classes
    body.classList.remove('high-contrast', 'reduced-motion', 'large-text');

    // Apply current theme classes
    if (this.preferences.highContrast) body.classList.add('high-contrast');
    if (this.preferences.reducedMotion) body.classList.add('reduced-motion');
    if (this.preferences.largeText) body.classList.add('large-text');

    // Update button states (aria-pressed attributes)
    this.updateButtonStates();

    // Update theme color meta tag
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      const themeColor = '#1a73e8'; // Always use light theme color
      themeColorMeta.setAttribute('content', themeColor);
    }

    // Update managers if they exist
    if (this.animationManager) {
      // Update the animation manager theme when preferences change
      this.animationManager.updateAnimationDefaults();
    }

    if (this.accessibilityManager) {
      this.accessibilityManager.updateTheme(this.preferences);
    }
  }

  /**
   * Update accessibility button states
   */
  updateButtonStates() {
    const highContrastBtn = document.getElementById('toggle-high-contrast');
    const largeTextBtn = document.getElementById('toggle-large-text');
    const reducedMotionBtn = document.getElementById('toggle-reduced-motion');

    if (highContrastBtn) {
      highContrastBtn.setAttribute(
        'aria-pressed',
        this.preferences.highContrast.toString()
      );
    }
    if (largeTextBtn) {
      largeTextBtn.setAttribute(
        'aria-pressed',
        this.preferences.largeText.toString()
      );
    }
    if (reducedMotionBtn) {
      reducedMotionBtn.setAttribute(
        'aria-pressed',
        this.preferences.reducedMotion.toString()
      );
    }
  }

  /**
   * Announce theme changes for accessibility
   */
  announceThemeChange() {
    const announcement = `Theme changed to ${this.currentTheme.replace('-', ' ')} mode`;

    if (this.accessibilityManager) {
      this.accessibilityManager.announce(announcement);
    } else {
      // Fallback announcement
      const liveRegion = document.getElementById('aria-live-polite');
      if (liveRegion) {
        liveRegion.textContent = announcement;
      }
    }
  }

  /**
   * Initialize error handling and recovery
   */
  initializeErrorHandling() {
    // Create error boundary element
    this.errorBoundary = document.getElementById('error-boundary');

    // Global error handlers
    window.addEventListener('error', event => {
      this.handleError(event.error, 'A JavaScript error occurred');
    });

    window.addEventListener('unhandledrejection', event => {
      this.handleError(event.reason, 'An unhandled promise rejection occurred');
    });

    AppDebug.log('Error handling initialized');
  }

  /**
   * Enhanced error handling with recovery options
   */
  handleError(error, userMessage = 'An unexpected error occurred') {
    this.lastError = error;
    AppDebug.error('App Error:', error);

    // Track error for analytics
    simpleAnalytics.trackEvent('app_error', {
      error_message: error.message || String(error),
      error_stack: error.stack,
      user_agent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    });

    // Show error to user
    this.showError(userMessage);

    // Announce error for accessibility
    if (this.accessibilityManager) {
      this.accessibilityManager.announce(`Error: ${userMessage}`, 'assertive');
    }
  }

  /**
   * Show error in error boundary
   */
  showError(message, isRecoverable = true) {
    if (!this.errorBoundary) {
      // Fallback to alert if no error boundary
      alert(message);
      return;
    }

    const errorContent = this.errorBoundary.querySelector('.error-content');
    if (errorContent) {
      const messageEl = errorContent.querySelector('.error-message');
      const retryBtn = errorContent.querySelector('#retry-action');
      const reportBtn = errorContent.querySelector('#report-error');

      if (messageEl) messageEl.textContent = message;

      // Setup retry functionality
      if (retryBtn && isRecoverable) {
        retryBtn.style.display = 'inline-block';
        retryBtn.onclick = () => {
          this.hideError();
          // Attempt to recover by reinitializing
          if (!this.isInitialized) {
            this.init();
          }
        };
      } else if (retryBtn) {
        retryBtn.style.display = 'none';
      }

      // Setup error reporting
      if (reportBtn) {
        reportBtn.onclick = () => {
          this.reportError();
        };
      }
    }

    this.errorBoundary.setAttribute('aria-hidden', 'false');
    this.errorBoundary.style.display = 'flex';
  }

  /**
   * Hide error boundary
   */
  hideError() {
    if (this.errorBoundary) {
      this.errorBoundary.setAttribute('aria-hidden', 'true');
      this.errorBoundary.style.display = 'none';
    }
  }

  /**
   * Report error to analytics/support
   */
  reportError() {
    if (this.lastError) {
      const errorReport = {
        message: this.lastError.message || String(this.lastError),
        stack: this.lastError.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: new Date().toISOString(),
        appState: {
          initialized: this.isInitialized,
          currentSimulation: this.currentSimulation?.id,
          theme: this.currentTheme,
        },
      };

      // Send to analytics
      simpleAnalytics.trackEvent('error_reported', errorReport);

      // Show confirmation
      alert(
        'Error report sent. Thank you for helping us improve the application.'
      );
    }
  }

  async initializeSystems() {
    try {
      // Initialize animation manager with theme preferences
      this.animationManager = new AnimationManager({
        enableAnimations: !this.preferences.reducedMotion,
        reducedMotion: this.preferences.reducedMotion,
        performanceMode: this.preferences.reducedMotion
          ? 'compatibility'
          : 'balanced',
      });

      // Initialize accessibility manager with current preferences
      this.accessibilityManager = new AccessibilityManager(document.body, {
        theme: this.currentTheme,
        preferences: this.preferences,
      });

      // Initialize core educational modules
      await this.initializeCoreModules();

      // Visual Engine will be initialized later when we have canvas elements
      // Just store the configuration for now
      this.visualEngineConfig = {
        renderMode: 'canvas',
        accessibility: true,
        highPerformance: !this.preferences.reducedMotion,
        debug: false,
        highContrast: this.preferences.highContrast,
        reducedMotion: this.preferences.reducedMotion,
      };

      // Systems are already initialized via their modules
      // Simple analytics auto-initializes
      AppDebug.log('Core systems initialized with modernized infrastructure');
    } catch (error) {
      AppDebug.error('Failed to initialize systems:', error);
      throw error;
    }
  }

  /**
   * Initialize core educational modules
   */
  async initializeCoreModules() {
    try {
      // Initialize Educator Toolkit
      this.educatorToolkit = new EducatorToolkit();
      AppDebug.log('Educator Toolkit initialized');

      // Initialize Digital Science Lab
      this.digitalScienceLab = new DigitalScienceLab();
      AppDebug.log('Digital Science Lab initialized');

      // Initialize Scenario Generator
      this.scenarioGenerator = new ScenarioGenerator();
      AppDebug.log('Scenario Generator initialized');

      // Connect the modules for integrated functionality
      this.connectEducationalModules();
    } catch (error) {
      AppDebug.error('Failed to initialize core educational modules:', error);
      throw error;
    }
  }

  /**
   * Connect educational modules for integrated functionality
   */
  connectEducationalModules() {
    // Connect scenario generator to educator toolkit for assessment alignment
    if (this.educatorToolkit && this.scenarioGenerator) {
      this.educatorToolkit.setScenarioGenerator(this.scenarioGenerator);
    }

    // Connect digital science lab to both toolkit and generator
    if (this.digitalScienceLab) {
      if (this.educatorToolkit) {
        this.digitalScienceLab.setEducatorToolkit(this.educatorToolkit);
      }
      if (this.scenarioGenerator) {
        this.digitalScienceLab.setScenarioGenerator(this.scenarioGenerator);
      }
    }

    AppDebug.log('Educational modules connected successfully');
  }

  /**
   * Connect core educational modules to a simulation instance
   * @param {Object} simulation - The simulation instance
   * @param {Object} config - The simulation configuration
   */
  connectModulesToSimulation(simulation, config) {
    try {
      // Connect Educator Toolkit
      if (this.educatorToolkit && simulation) {
        simulation.educatorToolkit = this.educatorToolkit;

        // Get curriculum alignment for this simulation
        const curriculumAlignment = this.educatorToolkit.getCurriculumAlignment(
          config.tags || []
        );
        if (curriculumAlignment) {
          simulation.curriculumAlignment = curriculumAlignment;
        }

        // Get assessment tools for this simulation
        const assessmentTools = this.educatorToolkit.getAssessmentTools(
          config.difficulty
        );
        if (assessmentTools) {
          simulation.assessmentTools = assessmentTools;
        }
      }

      // Connect Digital Science Lab
      if (this.digitalScienceLab && simulation) {
        simulation.digitalScienceLab = this.digitalScienceLab;

        // Get relevant lab stations for this simulation
        const relevantStations = this.digitalScienceLab.getRelevantStations(
          config.tags || []
        );
        if (relevantStations) {
          simulation.labStations = relevantStations;
        }
      }

      // Connect Scenario Generator
      if (this.scenarioGenerator && simulation) {
        simulation.scenarioGenerator = this.scenarioGenerator;

        // If this simulation can use generated scenarios, provide them
        if (simulation.supportsGeneratedScenarios) {
          const generatedScenarios = this.scenarioGenerator.generateScenarios(
            config.tags?.[0] || 'general',
            config.difficulty || 'beginner'
          );
          if (generatedScenarios) {
            simulation.generatedScenarios = generatedScenarios;
          }
        }
      }

      AppDebug.log(
        `Educational modules connected to simulation: ${simulation.id || 'unknown'}`
      );
    } catch (error) {
      AppDebug.error(
        'Failed to connect educational modules to simulation:',
        error
      );
      // Non-critical error - simulation can still function without full integration
    }
  }

  setupUI() {
    // Get key UI elements
    this.modal = document.getElementById('simulation-modal');
    this.simulationContainer = document.getElementById('simulation-container');
    this.categoriesGrid = document.querySelector(
      '.categories-grid, .simulations-grid'
    );
    this.loading = document.getElementById('loading');

    if (!this.categoriesGrid) {
      AppDebug.error('Categories grid not found');
      return;
    }

    // Initialize CategoryGrid
    this.initializeCategoryGrid();
  }

  /**
   * Initialize the new category grid system
   */
  initializeCategoryGrid() {
    try {
      this.categoryGrid = new CategoryGrid();
      AppDebug.log('Category grid initialized successfully');
    } catch (error) {
      AppDebug.error('Failed to initialize category grid:', error);
      // Fallback to legacy simulation loading if category grid fails
      this.loadLegacySimulations();
    }
  }

  /**
   * Fallback method for legacy simulation loading
   */
  loadLegacySimulations() {
    AppDebug.log('Loading legacy simulation cards as fallback');
    // This will be populated with existing simulation loading logic if needed
    // For now, just log that we're in fallback mode
  }

  async loadSimulations() {
    // Simulations are loaded dynamically in createSimulationInstance()
    // Store available simulation configs in the simulations Map
    this.availableSimulations.forEach(simConfig => {
      this.simulations.set(simConfig.id, simConfig);
    });
  }

  /**
   * Initialize hero demo component
   * Currently using radar chart demo instead of HeroDemo class
   */
  async initializeHeroDemo() {
    // The HeroDemo class is designed for a different hero layout
    // that's not currently implemented. The radar chart demo is working fine.
    logger.info(
      'App',
      'Hero demo: Using radar chart demo instead of HeroDemo class'
    );
  }

  /**
   * Initialize enhanced objects (visual components)
   */
  async initializeEnhancedObjects() {
    try {
      // Enhanced objects are loaded dynamically when needed
      // This method is kept for future initialization if needed
      logger.info('App', 'Enhanced objects system ready for dynamic loading');
    } catch (error) {
      logger.error('Failed to initialize enhanced objects:', error);
      // Non-critical error - app can continue with basic functionality
    }
  }

  /**
   * Initialize modal footer management system
   */
  initializeModalFooterManager() {
    try {
      // Initialize the modal footer manager
      this.modalFooterManager = new ModalFooterManager();

      // Store reference for cleanup
      this.modalFooterManager.app = this;

      logger.info('App', 'Modal footer manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize modal footer manager:', error);
      // Non-critical error - modals will still work with basic functionality
    }
  }

  /**
   * Initialize ethics radar demo system
   */
  async initializeEthicsRadarDemo() {
    try {
      // Only initialize if the hero demo container exists
      const demoContainer = document.getElementById('hero-ethics-chart');
      if (demoContainer) {
        // Initialize the ethics radar demo
        ethicsDemo = new EthicsRadarDemo();

        logger.info('App', 'Ethics radar demo initialized successfully');
      } else {
        logger.warn(
          'Hero ethics chart container not found, skipping radar demo initialization'
        );
      }
    } catch (error) {
      logger.error('Failed to initialize ethics radar demo:', error);
      // Non-critical error - the demo is optional
    }
  }

  setupEventListeners() {
    // Mobile navigation functionality
    this.setupMobileNavigation();

    // Surprise Me functionality
    this.setupSurpriseMe();

    // Tour functionality
    this.setupTourButton();

    // Hero section buttons
    const startLearningBtn = document.getElementById('start-learning');

    if (startLearningBtn) {
      startLearningBtn.addEventListener('click', () => {
        this.scrollToSimulations();
      });
    }

    // Debug: Test scenario modal button
    const testScenarioBtn = document.getElementById('test-scenario-modal');
    if (testScenarioBtn) {
      testScenarioBtn.addEventListener('click', () => {
        this.testScenarioModal();
      });
    }

    // Modal controls
    if (this.modal) {
      const closeBtn = this.modal.querySelector('.modal-close');
      const resetBtn = document.getElementById('reset-simulation');
      const nextBtn = document.getElementById('next-scenario');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeSimulation());

        // Add focus trapping to the modal
        this.modal.addEventListener('keydown', e => {
          if (e.key === 'Tab') {
            this.trapFocusInModal(e);
          }
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetCurrentSimulation());
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => this.nextScenario());
      }

      // Close modal on backdrop click
      this.modal.addEventListener('click', e => {
        if (e.target === this.modal) {
          this.closeSimulation();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !this.modal.hasAttribute('aria-hidden')) {
          this.closeSimulation();
        }
      });
    }

    // Enhanced simulation card buttons (delegated event handling)
    document.addEventListener('click', e => {
      if (e.target.classList.contains('enhanced-sim-button')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Learning Lab button - go through pre-launch modal
          this.startSimulation.call(this, simulationId);
        }
      } else if (e.target.classList.contains('simulation-quick-start-btn')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Quick start button - skip pre-launch modal
          this.launchSimulationDirect.call(this, simulationId);
        }
      }
    });
  }

  /**
   * Check if this is a first-time visit and start onboarding tour
   */
  checkAndStartOnboardingTour() {
    if (!this.onboardingTour) {
      return;
    }

    // Check if user has completed the tour
    if (this.onboardingTour.hasCompletedTour()) {
      AppDebug.log('User has already completed onboarding tour');
      return;
    }

    // Check if this is a first-time visit
    if (this.onboardingTour.isFirstTimeVisit()) {
      AppDebug.log('First-time visit detected, starting onboarding tour');
      // Small delay to ensure all UI is ready
      setTimeout(() => {
        this.onboardingTour.startTour(1);
      }, 500);
    }
  }

  /**
   * Initialize theme detection and monitoring
   */
  initializeTheme() {
    // Detect system preferences
    const prefersReducedMotion = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    const prefersHighContrast = window.matchMedia?.(
      '(prefers-contrast: high)'
    ).matches;

    // Get saved user preferences (they override system preferences)
    const savedPreferences = userPreferences.getAccessibilitySettings();

    // Use saved preferences if they exist, otherwise use system preferences
    this.preferences = {
      reducedMotion:
        savedPreferences.reducedMotion !== undefined
          ? savedPreferences.reducedMotion
          : prefersReducedMotion,
      highContrast:
        savedPreferences.highContrast !== undefined
          ? savedPreferences.highContrast
          : prefersHighContrast,
      largeText: savedPreferences.largeText || false, // Default to false
    };

    this.currentTheme = this.preferences.highContrast
      ? 'high-contrast'
      : 'light';

    // Apply initial theme
    this.applyTheme();

    // Monitor theme changes
    this.setupThemeMonitoring();

    AppDebug.log('Theme initialized:', this.currentTheme, this.preferences);
  }

  /**
   * Initialize scroll reveal header functionality
   */
  initializeScrollRevealHeader() {
    const header = document.querySelector('.header');
    if (!header) return;

    let lastScrollY = window.scrollY;

    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      // Don't hide header at the very top of the page
      if (currentScrollY <= 10) {
        header.classList.remove('header-hidden');
        header.classList.add('header-visible');
      } else {
        // Hide header when scrolling down, show when scrolling up
        if (currentScrollY > lastScrollY && currentScrollY > 100) {
          // Scrolling down - hide header
          header.classList.add('header-hidden');
          header.classList.remove('header-visible');
        } else if (currentScrollY < lastScrollY) {
          // Scrolling up - show header
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
      }

      lastScrollY = currentScrollY;
    };

    // Throttle scroll events for better performance
    let ticking = false;
    const throttledHandleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    // Initialize header as visible
    header.classList.add('header-visible');

    AppDebug.log('Scroll reveal header initialized');
  }

  /**
   * Setup theme change monitoring
   */
  setupThemeMonitoring() {
    const reducedMotionQuery = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    );
    const highContrastQuery = window.matchMedia?.('(prefers-contrast: high)');

    const handleThemeChange = () => {
      // Get current saved preferences to check which ones are user-set
      const savedPreferences = userPreferences.getAccessibilitySettings();

      // Only update preferences that haven't been explicitly set by the user
      const newPreferences = { ...this.preferences };

      // Update system-based preferences only if user hasn't overridden them
      if (savedPreferences.reducedMotion === undefined) {
        newPreferences.reducedMotion = reducedMotionQuery?.matches || false;
      }
      if (savedPreferences.highContrast === undefined) {
        newPreferences.highContrast = highContrastQuery?.matches || false;
      }
      // largeText is always user-controlled, so never auto-update it

      if (JSON.stringify(newPreferences) !== JSON.stringify(this.preferences)) {
        this.preferences = newPreferences;
        this.currentTheme = newPreferences.highContrast
          ? 'high-contrast'
          : 'light';
        this.applyTheme();
        this.announceThemeChange();

        AppDebug.log(
          'System theme changed, updated non-user-set preferences:',
          newPreferences
        );
      }
    };

    reducedMotionQuery?.addEventListener?.('change', handleThemeChange);
    highContrastQuery?.addEventListener?.('change', handleThemeChange);
  }

  /**
   * Apply current theme to the application
   */
  applyTheme() {
    const { body } = document;

    // Remove existing theme classes
    body.classList.remove('high-contrast', 'reduced-motion', 'large-text');

    // Apply current theme classes
    if (this.preferences.highContrast) body.classList.add('high-contrast');
    if (this.preferences.reducedMotion) body.classList.add('reduced-motion');
    if (this.preferences.largeText) body.classList.add('large-text');

    // Update button states (aria-pressed attributes)
    this.updateButtonStates();

    // Update theme color meta tag
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      const themeColor = '#1a73e8'; // Always use light theme color
      themeColorMeta.setAttribute('content', themeColor);
    }

    // Update managers if they exist
    if (this.animationManager) {
      // Update the animation manager theme when preferences change
      this.animationManager.updateAnimationDefaults();
    }

    if (this.accessibilityManager) {
      this.accessibilityManager.updateTheme(this.preferences);
    }
  }

  /**
   * Update accessibility button states
   */
  updateButtonStates() {
    const highContrastBtn = document.getElementById('toggle-high-contrast');
    const largeTextBtn = document.getElementById('toggle-large-text');
    const reducedMotionBtn = document.getElementById('toggle-reduced-motion');

    if (highContrastBtn) {
      highContrastBtn.setAttribute(
        'aria-pressed',
        this.preferences.highContrast.toString()
      );
    }
    if (largeTextBtn) {
      largeTextBtn.setAttribute(
        'aria-pressed',
        this.preferences.largeText.toString()
      );
    }
    if (reducedMotionBtn) {
      reducedMotionBtn.setAttribute(
        'aria-pressed',
        this.preferences.reducedMotion.toString()
      );
    }
  }

  /**
   * Announce theme changes for accessibility
   */
  announceThemeChange() {
    const announcement = `Theme changed to ${this.currentTheme.replace('-', ' ')} mode`;

    if (this.accessibilityManager) {
      this.accessibilityManager.announce(announcement);
    } else {
      // Fallback announcement
      const liveRegion = document.getElementById('aria-live-polite');
      if (liveRegion) {
        liveRegion.textContent = announcement;
      }
    }
  }

  /**
   * Initialize error handling and recovery
   */
  initializeErrorHandling() {
    // Create error boundary element
    this.errorBoundary = document.getElementById('error-boundary');

    // Global error handlers
    window.addEventListener('error', event => {
      this.handleError(event.error, 'A JavaScript error occurred');
    });

    window.addEventListener('unhandledrejection', event => {
      this.handleError(event.reason, 'An unhandled promise rejection occurred');
    });

    AppDebug.log('Error handling initialized');
  }

  /**
   * Enhanced error handling with recovery options
   */
  handleError(error, userMessage = 'An unexpected error occurred') {
    this.lastError = error;
    AppDebug.error('App Error:', error);

    // Track error for analytics
    simpleAnalytics.trackEvent('app_error', {
      error_message: error.message || String(error),
      error_stack: error.stack,
      user_agent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    });

    // Show error to user
    this.showError(userMessage);

    // Announce error for accessibility
    if (this.accessibilityManager) {
      this.accessibilityManager.announce(`Error: ${userMessage}`, 'assertive');
    }
  }

  /**
   * Show error in error boundary
   */
  showError(message, isRecoverable = true) {
    if (!this.errorBoundary) {
      // Fallback to alert if no error boundary
      alert(message);
      return;
    }

    const errorContent = this.errorBoundary.querySelector('.error-content');
    if (errorContent) {
      const messageEl = errorContent.querySelector('.error-message');
      const retryBtn = errorContent.querySelector('#retry-action');
      const reportBtn = errorContent.querySelector('#report-error');

      if (messageEl) messageEl.textContent = message;

      // Setup retry functionality
      if (retryBtn && isRecoverable) {
        retryBtn.style.display = 'inline-block';
        retryBtn.onclick = () => {
          this.hideError();
          // Attempt to recover by reinitializing
          if (!this.isInitialized) {
            this.init();
          }
        };
      } else if (retryBtn) {
        retryBtn.style.display = 'none';
      }

      // Setup error reporting
      if (reportBtn) {
        reportBtn.onclick = () => {
          this.reportError();
        };
      }
    }

    this.errorBoundary.setAttribute('aria-hidden', 'false');
    this.errorBoundary.style.display = 'flex';
  }

  /**
   * Hide error boundary
   */
  hideError() {
    if (this.errorBoundary) {
      this.errorBoundary.setAttribute('aria-hidden', 'true');
      this.errorBoundary.style.display = 'none';
    }
  }

  /**
   * Report error to analytics/support
   */
  reportError() {
    if (this.lastError) {
      const errorReport = {
        message: this.lastError.message || String(this.lastError),
        stack: this.lastError.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: new Date().toISOString(),
        appState: {
          initialized: this.isInitialized,
          currentSimulation: this.currentSimulation?.id,
          theme: this.currentTheme,
        },
      };

      // Send to analytics
      simpleAnalytics.trackEvent('error_reported', errorReport);

      // Show confirmation
      alert(
        'Error report sent. Thank you for helping us improve the application.'
      );
    }
  }

  async initializeSystems() {
    try {
      // Initialize animation manager with theme preferences
      this.animationManager = new AnimationManager({
        enableAnimations: !this.preferences.reducedMotion,
        reducedMotion: this.preferences.reducedMotion,
        performanceMode: this.preferences.reducedMotion
          ? 'compatibility'
          : 'balanced',
      });

      // Initialize accessibility manager with current preferences
      this.accessibilityManager = new AccessibilityManager(document.body, {
        theme: this.currentTheme,
        preferences: this.preferences,
      });

      // Initialize core educational modules
      await this.initializeCoreModules();

      // Visual Engine will be initialized later when we have canvas elements
      // Just store the configuration for now
      this.visualEngineConfig = {
        renderMode: 'canvas',
        accessibility: true,
        highPerformance: !this.preferences.reducedMotion,
        debug: false,
        highContrast: this.preferences.highContrast,
        reducedMotion: this.preferences.reducedMotion,
      };

      // Systems are already initialized via their modules
      // Simple analytics auto-initializes
      AppDebug.log('Core systems initialized with modernized infrastructure');
    } catch (error) {
      AppDebug.error('Failed to initialize systems:', error);
      throw error;
    }
  }

  /**
   * Initialize core educational modules
   */
  async initializeCoreModules() {
    try {
      // Initialize Educator Toolkit
      this.educatorToolkit = new EducatorToolkit();
      AppDebug.log('Educator Toolkit initialized');

      // Initialize Digital Science Lab
      this.digitalScienceLab = new DigitalScienceLab();
      AppDebug.log('Digital Science Lab initialized');

      // Initialize Scenario Generator
      this.scenarioGenerator = new ScenarioGenerator();
      AppDebug.log('Scenario Generator initialized');

      // Connect the modules for integrated functionality
      this.connectEducationalModules();
    } catch (error) {
      AppDebug.error('Failed to initialize core educational modules:', error);
      throw error;
    }
  }

  /**
   * Connect educational modules for integrated functionality
   */
  connectEducationalModules() {
    // Connect scenario generator to educator toolkit for assessment alignment
    if (this.educatorToolkit && this.scenarioGenerator) {
      this.educatorToolkit.setScenarioGenerator(this.scenarioGenerator);
    }

    // Connect digital science lab to both toolkit and generator
    if (this.digitalScienceLab) {
      if (this.educatorToolkit) {
        this.digitalScienceLab.setEducatorToolkit(this.educatorToolkit);
      }
      if (this.scenarioGenerator) {
        this.digitalScienceLab.setScenarioGenerator(this.scenarioGenerator);
      }
    }

    AppDebug.log('Educational modules connected successfully');
  }

  /**
   * Connect core educational modules to a simulation instance
   * @param {Object} simulation - The simulation instance
   * @param {Object} config - The simulation configuration
   */
  connectModulesToSimulation(simulation, config) {
    try {
      // Connect Educator Toolkit
      if (this.educatorToolkit && simulation) {
        simulation.educatorToolkit = this.educatorToolkit;

        // Get curriculum alignment for this simulation
        const curriculumAlignment = this.educatorToolkit.getCurriculumAlignment(
          config.tags || []
        );
        if (curriculumAlignment) {
          simulation.curriculumAlignment = curriculumAlignment;
        }

        // Get assessment tools for this simulation
        const assessmentTools = this.educatorToolkit.getAssessmentTools(
          config.difficulty
        );
        if (assessmentTools) {
          simulation.assessmentTools = assessmentTools;
        }
      }

      // Connect Digital Science Lab
      if (this.digitalScienceLab && simulation) {
        simulation.digitalScienceLab = this.digitalScienceLab;

        // Get relevant lab stations for this simulation
        const relevantStations = this.digitalScienceLab.getRelevantStations(
          config.tags || []
        );
        if (relevantStations) {
          simulation.labStations = relevantStations;
        }
      }

      // Connect Scenario Generator
      if (this.scenarioGenerator && simulation) {
        simulation.scenarioGenerator = this.scenarioGenerator;

        // If this simulation can use generated scenarios, provide them
        if (simulation.supportsGeneratedScenarios) {
          const generatedScenarios = this.scenarioGenerator.generateScenarios(
            config.tags?.[0] || 'general',
            config.difficulty || 'beginner'
          );
          if (generatedScenarios) {
            simulation.generatedScenarios = generatedScenarios;
          }
        }
      }

      AppDebug.log(
        `Educational modules connected to simulation: ${simulation.id || 'unknown'}`
      );
    } catch (error) {
      AppDebug.error(
        'Failed to connect educational modules to simulation:',
        error
      );
      // Non-critical error - simulation can still function without full integration
    }
  }

  setupUI() {
    // Get key UI elements
    this.modal = document.getElementById('simulation-modal');
    this.simulationContainer = document.getElementById('simulation-container');
    this.categoriesGrid = document.querySelector(
      '.categories-grid, .simulations-grid'
    );
    this.loading = document.getElementById('loading');

    if (!this.categoriesGrid) {
      AppDebug.error('Categories grid not found');
      return;
    }

    // Initialize CategoryGrid
    this.initializeCategoryGrid();
  }

  /**
   * Initialize the new category grid system
   */
  initializeCategoryGrid() {
    try {
      this.categoryGrid = new CategoryGrid();
      AppDebug.log('Category grid initialized successfully');
    } catch (error) {
      AppDebug.error('Failed to initialize category grid:', error);
      // Fallback to legacy simulation loading if category grid fails
      this.loadLegacySimulations();
    }
  }

  /**
   * Fallback method for legacy simulation loading
   */
  loadLegacySimulations() {
    AppDebug.log('Loading legacy simulation cards as fallback');
    // This will be populated with existing simulation loading logic if needed
    // For now, just log that we're in fallback mode
  }

  async loadSimulations() {
    // Simulations are loaded dynamically in createSimulationInstance()
    // Store available simulation configs in the simulations Map
    this.availableSimulations.forEach(simConfig => {
      this.simulations.set(simConfig.id, simConfig);
    });
  }

  /**
   * Initialize hero demo component
   * Currently using radar chart demo instead of HeroDemo class
   */
  async initializeHeroDemo() {
    // The HeroDemo class is designed for a different hero layout
    // that's not currently implemented. The radar chart demo is working fine.
    logger.info(
      'App',
      'Hero demo: Using radar chart demo instead of HeroDemo class'
    );
  }

  /**
   * Initialize enhanced objects (visual components)
   */
  async initializeEnhancedObjects() {
    try {
      // Enhanced objects are loaded dynamically when needed
      // This method is kept for future initialization if needed
      logger.info('App', 'Enhanced objects system ready for dynamic loading');
    } catch (error) {
      logger.error('Failed to initialize enhanced objects:', error);
      // Non-critical error - app can continue with basic functionality
    }
  }

  /**
   * Initialize modal footer management system
   */
  initializeModalFooterManager() {
    try {
      // Initialize the modal footer manager
      this.modalFooterManager = new ModalFooterManager();

      // Store reference for cleanup
      this.modalFooterManager.app = this;

      logger.info('App', 'Modal footer manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize modal footer manager:', error);
      // Non-critical error - modals will still work with basic functionality
    }
  }

  /**
   * Initialize ethics radar demo system
   */
  async initializeEthicsRadarDemo() {
    try {
      // Only initialize if the hero demo container exists
      const demoContainer = document.getElementById('hero-ethics-chart');
      if (demoContainer) {
        // Initialize the ethics radar demo
        ethicsDemo = new EthicsRadarDemo();

        logger.info('App', 'Ethics radar demo initialized successfully');
      } else {
        logger.warn(
          'Hero ethics chart container not found, skipping radar demo initialization'
        );
      }
    } catch (error) {
      logger.error('Failed to initialize ethics radar demo:', error);
      // Non-critical error - the demo is optional
    }
  }

  setupEventListeners() {
    // Mobile navigation functionality
    this.setupMobileNavigation();

    // Surprise Me functionality
    this.setupSurpriseMe();

    // Tour functionality
    this.setupTourButton();

    // Hero section buttons
    const startLearningBtn = document.getElementById('start-learning');

    if (startLearningBtn) {
      startLearningBtn.addEventListener('click', () => {
        this.scrollToSimulations();
      });
    }

    // Debug: Test scenario modal button
    const testScenarioBtn = document.getElementById('test-scenario-modal');
    if (testScenarioBtn) {
      testScenarioBtn.addEventListener('click', () => {
        this.testScenarioModal();
      });
    }

    // Modal controls
    if (this.modal) {
      const closeBtn = this.modal.querySelector('.modal-close');
      const resetBtn = document.getElementById('reset-simulation');
      const nextBtn = document.getElementById('next-scenario');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeSimulation());

        // Add focus trapping to the modal
        this.modal.addEventListener('keydown', e => {
          if (e.key === 'Tab') {
            this.trapFocusInModal(e);
          }
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetCurrentSimulation());
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => this.nextScenario());
      }

      // Close modal on backdrop click
      this.modal.addEventListener('click', e => {
        if (e.target === this.modal) {
          this.closeSimulation();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !this.modal.hasAttribute('aria-hidden')) {
          this.closeSimulation();
        }
      });
    }

    // Enhanced simulation card buttons (delegated event handling)
    document.addEventListener('click', e => {
      if (e.target.classList.contains('enhanced-sim-button')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Learning Lab button - go through pre-launch modal
          this.startSimulation.call(this, simulationId);
        }
      } else if (e.target.classList.contains('simulation-quick-start-btn')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Quick start button - skip pre-launch modal
          this.launchSimulationDirect.call(this, simulationId);
        }
      }
    });
  }

  /**
   * Check if this is a first-time visit and start onboarding tour
   */
  checkAndStartOnboardingTour() {
    if (!this.onboardingTour) {
      return;
    }

    // Check if user has completed the tour
    if (this.onboardingTour.hasCompletedTour()) {
      AppDebug.log('User has already completed onboarding tour');
      return;
    }

    // Check if this is a first-time visit
    if (this.onboardingTour.isFirstTimeVisit()) {
      AppDebug.log('First-time visit detected, starting onboarding tour');
      // Small delay to ensure all UI is ready
      setTimeout(() => {
        this.onboardingTour.startTour(1);
      }, 500);
    }
  }

  /**
   * Initialize theme detection and monitoring
   */
  initializeTheme() {
    // Detect system preferences
    const prefersReducedMotion = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    const prefersHighContrast = window.matchMedia?.(
      '(prefers-contrast: high)'
    ).matches;

    // Get saved user preferences (they override system preferences)
    const savedPreferences = userPreferences.getAccessibilitySettings();

    // Use saved preferences if they exist, otherwise use system preferences
    this.preferences = {
      reducedMotion:
        savedPreferences.reducedMotion !== undefined
          ? savedPreferences.reducedMotion
          : prefersReducedMotion,
      highContrast:
        savedPreferences.highContrast !== undefined
          ? savedPreferences.highContrast
          : prefersHighContrast,
      largeText: savedPreferences.largeText || false, // Default to false
    };

    this.currentTheme = this.preferences.highContrast
      ? 'high-contrast'
      : 'light';

    // Apply initial theme
    this.applyTheme();

    // Monitor theme changes
    this.setupThemeMonitoring();

    AppDebug.log('Theme initialized:', this.currentTheme, this.preferences);
  }

  /**
   * Initialize scroll reveal header functionality
   */
  initializeScrollRevealHeader() {
    const header = document.querySelector('.header');
    if (!header) return;

    let lastScrollY = window.scrollY;

    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      // Don't hide header at the very top of the page
      if (currentScrollY <= 10) {
        header.classList.remove('header-hidden');
        header.classList.add('header-visible');
      } else {
        // Hide header when scrolling down, show when scrolling up
        if (currentScrollY > lastScrollY && currentScrollY > 100) {
          // Scrolling down - hide header
          header.classList.add('header-hidden');
          header.classList.remove('header-visible');
        } else if (currentScrollY < lastScrollY) {
          // Scrolling up - show header
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
      }

      lastScrollY = currentScrollY;
    };

    // Throttle scroll events for better performance
    let ticking = false;
    const throttledHandleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    // Initialize header as visible
    header.classList.add('header-visible');

    AppDebug.log('Scroll reveal header initialized');
  }

  /**
   * Setup theme change monitoring
   */
  setupThemeMonitoring() {
    const reducedMotionQuery = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    );
    const highContrastQuery = window.matchMedia?.('(prefers-contrast: high)');

    const handleThemeChange = () => {
      // Get current saved preferences to check which ones are user-set
      const savedPreferences = userPreferences.getAccessibilitySettings();

      // Only update preferences that haven't been explicitly set by the user
      const newPreferences = { ...this.preferences };

      // Update system-based preferences only if user hasn't overridden them
      if (savedPreferences.reducedMotion === undefined) {
        newPreferences.reducedMotion = reducedMotionQuery?.matches || false;
      }
      if (savedPreferences.highContrast === undefined) {
        newPreferences.highContrast = highContrastQuery?.matches || false;
      }
      // largeText is always user-controlled, so never auto-update it

      if (JSON.stringify(newPreferences) !== JSON.stringify(this.preferences)) {
        this.preferences = newPreferences;
        this.currentTheme = newPreferences.highContrast
          ? 'high-contrast'
          : 'light';
        this.applyTheme();
        this.announceThemeChange();

        AppDebug.log(
          'System theme changed, updated non-user-set preferences:',
          newPreferences
        );
      }
    };

    reducedMotionQuery?.addEventListener?.('change', handleThemeChange);
    highContrastQuery?.addEventListener?.('change', handleThemeChange);
  }

  /**
   * Apply current theme to the application
   */
  applyTheme() {
    const { body } = document;

    // Remove existing theme classes
    body.classList.remove('high-contrast', 'reduced-motion', 'large-text');

    // Apply current theme classes
    if (this.preferences.highContrast) body.classList.add('high-contrast');
    if (this.preferences.reducedMotion) body.classList.add('reduced-motion');
    if (this.preferences.largeText) body.classList.add('large-text');

    // Update button states (aria-pressed attributes)
    this.updateButtonStates();

    // Update theme color meta tag
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      const themeColor = '#1a73e8'; // Always use light theme color
      themeColorMeta.setAttribute('content', themeColor);
    }

    // Update managers if they exist
    if (this.animationManager) {
      // Update the animation manager theme when preferences change
      this.animationManager.updateAnimationDefaults();
    }

    if (this.accessibilityManager) {
      this.accessibilityManager.updateTheme(this.preferences);
    }
  }

  /**
   * Update accessibility button states
   */
  updateButtonStates() {
    const highContrastBtn = document.getElementById('toggle-high-contrast');
    const largeTextBtn = document.getElementById('toggle-large-text');
    const reducedMotionBtn = document.getElementById('toggle-reduced-motion');

    if (highContrastBtn) {
      highContrastBtn.setAttribute(
        'aria-pressed',
        this.preferences.highContrast.toString()
      );
    }
    if (largeTextBtn) {
      largeTextBtn.setAttribute(
        'aria-pressed',
        this.preferences.largeText.toString()
      );
    }
    if (reducedMotionBtn) {
      reducedMotionBtn.setAttribute(
        'aria-pressed',
        this.preferences.reducedMotion.toString()
      );
    }
  }

  /**
   * Announce theme changes for accessibility
   */
  announceThemeChange() {
    const announcement = `Theme changed to ${this.currentTheme.replace('-', ' ')} mode`;

    if (this.accessibilityManager) {
      this.accessibilityManager.announce(announcement);
    } else {
      // Fallback announcement
      const liveRegion = document.getElementById('aria-live-polite');
      if (liveRegion) {
        liveRegion.textContent = announcement;
      }
    }
  }

  /**
   * Initialize error handling and recovery
   */
  initializeErrorHandling() {
    // Create error boundary element
    this.errorBoundary = document.getElementById('error-boundary');

    // Global error handlers
    window.addEventListener('error', event => {
      this.handleError(event.error, 'A JavaScript error occurred');
    });

    window.addEventListener('unhandledrejection', event => {
      this.handleError(event.reason, 'An unhandled promise rejection occurred');
    });

    AppDebug.log('Error handling initialized');
  }

  /**
   * Enhanced error handling with recovery options
   */
  handleError(error, userMessage = 'An unexpected error occurred') {
    this.lastError = error;
    AppDebug.error('App Error:', error);

    // Track error for analytics
    simpleAnalytics.trackEvent('app_error', {
      error_message: error.message || String(error),
      error_stack: error.stack,
      user_agent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    });

    // Show error to user
    this.showError(userMessage);

    // Announce error for accessibility
    if (this.accessibilityManager) {
      this.accessibilityManager.announce(`Error: ${userMessage}`, 'assertive');
    }
  }

  /**
   * Show error in error boundary
   */
  showError(message, isRecoverable = true) {
    if (!this.errorBoundary) {
      // Fallback to alert if no error boundary
      alert(message);
      return;
    }

    const errorContent = this.errorBoundary.querySelector('.error-content');
    if (errorContent) {
      const messageEl = errorContent.querySelector('.error-message');
      const retryBtn = errorContent.querySelector('#retry-action');
      const reportBtn = errorContent.querySelector('#report-error');

      if (messageEl) messageEl.textContent = message;

      // Setup retry functionality
      if (retryBtn && isRecoverable) {
        retryBtn.style.display = 'inline-block';
        retryBtn.onclick = () => {
          this.hideError();
          // Attempt to recover by reinitializing
          if (!this.isInitialized) {
            this.init();
          }
        };
      } else if (retryBtn) {
        retryBtn.style.display = 'none';
      }

      // Setup error reporting
      if (reportBtn) {
        reportBtn.onclick = () => {
          this.reportError();
        };
      }
    }

    this.errorBoundary.setAttribute('aria-hidden', 'false');
    this.errorBoundary.style.display = 'flex';
  }

  /**
   * Hide error boundary
   */
  hideError() {
    if (this.errorBoundary) {
      this.errorBoundary.setAttribute('aria-hidden', 'true');
      this.errorBoundary.style.display = 'none';
    }
  }

  /**
   * Report error to analytics/support
   */
  reportError() {
    if (this.lastError) {
      const errorReport = {
        message: this.lastError.message || String(this.lastError),
        stack: this.lastError.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: new Date().toISOString(),
        appState: {
          initialized: this.isInitialized,
          currentSimulation: this.currentSimulation?.id,
          theme: this.currentTheme,
        },
      };

      // Send to analytics
      simpleAnalytics.trackEvent('error_reported', errorReport);

      // Show confirmation
      alert(
        'Error report sent. Thank you for helping us improve the application.'
      );
    }
  }

  async initializeSystems() {
    try {
      // Initialize animation manager with theme preferences
      this.animationManager = new AnimationManager({
        enableAnimations: !this.preferences.reducedMotion,
        reducedMotion: this.preferences.reducedMotion,
        performanceMode: this.preferences.reducedMotion
          ? 'compatibility'
          : 'balanced',
      });

      // Initialize accessibility manager with current preferences
      this.accessibilityManager = new AccessibilityManager(document.body, {
        theme: this.currentTheme,
        preferences: this.preferences,
      });

      // Initialize core educational modules
      await this.initializeCoreModules();

      // Visual Engine will be initialized later when we have canvas elements
      // Just store the configuration for now
      this.visualEngineConfig = {
        renderMode: 'canvas',
        accessibility: true,
        highPerformance: !this.preferences.reducedMotion,
        debug: false,
        highContrast: this.preferences.highContrast,
        reducedMotion: this.preferences.reducedMotion,
      };

      // Systems are already initialized via their modules
      // Simple analytics auto-initializes
      AppDebug.log('Core systems initialized with modernized infrastructure');
    } catch (error) {
      AppDebug.error('Failed to initialize systems:', error);
      throw error;
    }
  }

  /**
   * Initialize core educational modules
   */
  async initializeCoreModules() {
    try {
      // Initialize Educator Toolkit
      this.educatorToolkit = new EducatorToolkit();
      AppDebug.log('Educator Toolkit initialized');

      // Initialize Digital Science Lab
      this.digitalScienceLab = new DigitalScienceLab();
      AppDebug.log('Digital Science Lab initialized');

      // Initialize Scenario Generator
      this.scenarioGenerator = new ScenarioGenerator();
      AppDebug.log('Scenario Generator initialized');

      // Connect the modules for integrated functionality
      this.connectEducationalModules();
    } catch (error) {
      AppDebug.error('Failed to initialize core educational modules:', error);
      throw error;
    }
  }

  /**
   * Connect educational modules for integrated functionality
   */
  connectEducationalModules() {
    // Connect scenario generator to educator toolkit for assessment alignment
    if (this.educatorToolkit && this.scenarioGenerator) {
      this.educatorToolkit.setScenarioGenerator(this.scenarioGenerator);
    }

    // Connect digital science lab to both toolkit and generator
    if (this.digitalScienceLab) {
      if (this.educatorToolkit) {
        this.digitalScienceLab.setEducatorToolkit(this.educatorToolkit);
      }
      if (this.scenarioGenerator) {
        this.digitalScienceLab.setScenarioGenerator(this.scenarioGenerator);
      }
    }

    AppDebug.log('Educational modules connected successfully');
  }

  /**
   * Connect core educational modules to a simulation instance
   * @param {Object} simulation - The simulation instance
   * @param {Object} config - The simulation configuration
   */
  connectModulesToSimulation(simulation, config) {
    try {
      // Connect Educator Toolkit
      if (this.educatorToolkit && simulation) {
        simulation.educatorToolkit = this.educatorToolkit;

        // Get curriculum alignment for this simulation
        const curriculumAlignment = this.educatorToolkit.getCurriculumAlignment(
          config.tags || []
        );
        if (curriculumAlignment) {
          simulation.curriculumAlignment = curriculumAlignment;
        }

        // Get assessment tools for this simulation
        const assessmentTools = this.educatorToolkit.getAssessmentTools(
          config.difficulty
        );
        if (assessmentTools) {
          simulation.assessmentTools = assessmentTools;
        }
      }

      // Connect Digital Science Lab
      if (this.digitalScienceLab && simulation) {
        simulation.digitalScienceLab = this.digitalScienceLab;

        // Get relevant lab stations for this simulation
        const relevantStations = this.digitalScienceLab.getRelevantStations(
          config.tags || []
        );
        if (relevantStations) {
          simulation.labStations = relevantStations;
        }
      }

      // Connect Scenario Generator
      if (this.scenarioGenerator && simulation) {
        simulation.scenarioGenerator = this.scenarioGenerator;

        // If this simulation can use generated scenarios, provide them
        if (simulation.supportsGeneratedScenarios) {
          const generatedScenarios = this.scenarioGenerator.generateScenarios(
            config.tags?.[0] || 'general',
            config.difficulty || 'beginner'
          );
          if (generatedScenarios) {
            simulation.generatedScenarios = generatedScenarios;
          }
        }
      }

      AppDebug.log(
        `Educational modules connected to simulation: ${simulation.id || 'unknown'}`
      );
    } catch (error) {
      AppDebug.error(
        'Failed to connect educational modules to simulation:',
        error
      );
      // Non-critical error - simulation can still function without full integration
    }
  }

  setupUI() {
    // Get key UI elements
    this.modal = document.getElementById('simulation-modal');
    this.simulationContainer = document.getElementById('simulation-container');
    this.categoriesGrid = document.querySelector(
      '.categories-grid, .simulations-grid'
    );
    this.loading = document.getElementById('loading');

    if (!this.categoriesGrid) {
      AppDebug.error('Categories grid not found');
      return;
    }

    // Initialize CategoryGrid
    this.initializeCategoryGrid();
  }

  /**
   * Initialize the new category grid system
   */
  initializeCategoryGrid() {
    try {
      this.categoryGrid = new CategoryGrid();
      AppDebug.log('Category grid initialized successfully');
    } catch (error) {
      AppDebug.error('Failed to initialize category grid:', error);
      // Fallback to legacy simulation loading if category grid fails
      this.loadLegacySimulations();
    }
  }

  /**
   * Fallback method for legacy simulation loading
   */
  loadLegacySimulations() {
    AppDebug.log('Loading legacy simulation cards as fallback');
    // This will be populated with existing simulation loading logic if needed
    // For now, just log that we're in fallback mode
  }

  async loadSimulations() {
    // Simulations are loaded dynamically in createSimulationInstance()
    // Store available simulation configs in the simulations Map
    this.availableSimulations.forEach(simConfig => {
      this.simulations.set(simConfig.id, simConfig);
    });
  }

  /**
   * Initialize hero demo component
   * Currently using radar chart demo instead of HeroDemo class
   */
  async initializeHeroDemo() {
    // The HeroDemo class is designed for a different hero layout
    // that's not currently implemented. The radar chart demo is working fine.
    logger.info(
      'App',
      'Hero demo: Using radar chart demo instead of HeroDemo class'
    );
  }

  /**
   * Initialize enhanced objects (visual components)
   */
  async initializeEnhancedObjects() {
    try {
      // Enhanced objects are loaded dynamically when needed
      // This method is kept for future initialization if needed
      logger.info('App', 'Enhanced objects system ready for dynamic loading');
    } catch (error) {
      logger.error('Failed to initialize enhanced objects:', error);
      // Non-critical error - app can continue with basic functionality
    }
  }

  /**
   * Initialize modal footer management system
   */
  initializeModalFooterManager() {
    try {
      // Initialize the modal footer manager
      this.modalFooterManager = new ModalFooterManager();

      // Store reference for cleanup
      this.modalFooterManager.app = this;

      logger.info('App', 'Modal footer manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize modal footer manager:', error);
      // Non-critical error - modals will still work with basic functionality
    }
  }

  /**
   * Initialize ethics radar demo system
   */
  async initializeEthicsRadarDemo() {
    try {
      // Only initialize if the hero demo container exists
      const demoContainer = document.getElementById('hero-ethics-chart');
      if (demoContainer) {
        // Initialize the ethics radar demo
        ethicsDemo = new EthicsRadarDemo();

        logger.info('App', 'Ethics radar demo initialized successfully');
      } else {
        logger.warn(
          'Hero ethics chart container not found, skipping radar demo initialization'
        );
      }
    } catch (error) {
      logger.error('Failed to initialize ethics radar demo:', error);
      // Non-critical error - the demo is optional
    }
  }

  setupEventListeners() {
    // Mobile navigation functionality
    this.setupMobileNavigation();

    // Surprise Me functionality
    this.setupSurpriseMe();

    // Tour functionality
    this.setupTourButton();

    // Hero section buttons
    const startLearningBtn = document.getElementById('start-learning');

    if (startLearningBtn) {
      startLearningBtn.addEventListener('click', () => {
        this.scrollToSimulations();
      });
    }

    // Debug: Test scenario modal button
    const testScenarioBtn = document.getElementById('test-scenario-modal');
    if (testScenarioBtn) {
      testScenarioBtn.addEventListener('click', () => {
        this.testScenarioModal();
      });
    }

    // Modal controls
    if (this.modal) {
      const closeBtn = this.modal.querySelector('.modal-close');
      const resetBtn = document.getElementById('reset-simulation');
      const nextBtn = document.getElementById('next-scenario');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeSimulation());

        // Add focus trapping to the modal
        this.modal.addEventListener('keydown', e => {
          if (e.key === 'Tab') {
            this.trapFocusInModal(e);
          }
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetCurrentSimulation());
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => this.nextScenario());
      }

      // Close modal on backdrop click
      this.modal.addEventListener('click', e => {
        if (e.target === this.modal) {
          this.closeSimulation();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !this.modal.hasAttribute('aria-hidden')) {
          this.closeSimulation();
        }
      });
    }

    // Enhanced simulation card buttons (delegated event handling)
    document.addEventListener('click', e => {
      if (e.target.classList.contains('enhanced-sim-button')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Learning Lab button - go through pre-launch modal
          this.startSimulation.call(this, simulationId);
        }
      } else if (e.target.classList.contains('simulation-quick-start-btn')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Quick start button - skip pre-launch modal
          this.launchSimulationDirect.call(this, simulationId);
        }
      }
    });
  }

  /**
   * Check if this is a first-time visit and start onboarding tour
   */
  checkAndStartOnboardingTour() {
    if (!this.onboardingTour) {
      return;
    }

    // Check if user has completed the tour
    if (this.onboardingTour.hasCompletedTour()) {
      AppDebug.log('User has already completed onboarding tour');
      return;
    }

    // Check if this is a first-time visit
    if (this.onboardingTour.isFirstTimeVisit()) {
      AppDebug.log('First-time visit detected, starting onboarding tour');
      // Small delay to ensure all UI is ready
      setTimeout(() => {
        this.onboardingTour.startTour(1);
      }, 500);
    }
  }

  /**
   * Initialize theme detection and monitoring
   */
  initializeTheme() {
    // Detect system preferences
    const prefersReducedMotion = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    ).matches;
    const prefersHighContrast = window.matchMedia?.(
      '(prefers-contrast: high)'
    ).matches;

    // Get saved user preferences (they override system preferences)
    const savedPreferences = userPreferences.getAccessibilitySettings();

    // Use saved preferences if they exist, otherwise use system preferences
    this.preferences = {
      reducedMotion:
        savedPreferences.reducedMotion !== undefined
          ? savedPreferences.reducedMotion
          : prefersReducedMotion,
      highContrast:
        savedPreferences.highContrast !== undefined
          ? savedPreferences.highContrast
          : prefersHighContrast,
      largeText: savedPreferences.largeText || false, // Default to false
    };

    this.currentTheme = this.preferences.highContrast
      ? 'high-contrast'
      : 'light';

    // Apply initial theme
    this.applyTheme();

    // Monitor theme changes
    this.setupThemeMonitoring();

    AppDebug.log('Theme initialized:', this.currentTheme, this.preferences);
  }

  /**
   * Initialize scroll reveal header functionality
   */
  initializeScrollRevealHeader() {
    const header = document.querySelector('.header');
    if (!header) return;

    let lastScrollY = window.scrollY;

    const handleScroll = () => {
      const currentScrollY = window.scrollY;

      // Don't hide header at the very top of the page
      if (currentScrollY <= 10) {
        header.classList.remove('header-hidden');
        header.classList.add('header-visible');
      } else {
        // Hide header when scrolling down, show when scrolling up
        if (currentScrollY > lastScrollY && currentScrollY > 100) {
          // Scrolling down - hide header
          header.classList.add('header-hidden');
          header.classList.remove('header-visible');
        } else if (currentScrollY < lastScrollY) {
          // Scrolling up - show header
          header.classList.remove('header-hidden');
          header.classList.add('header-visible');
        }
      }

      lastScrollY = currentScrollY;
    };

    // Throttle scroll events for better performance
    let ticking = false;
    const throttledHandleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', throttledHandleScroll, { passive: true });

    // Initialize header as visible
    header.classList.add('header-visible');

    AppDebug.log('Scroll reveal header initialized');
  }

  /**
   * Setup theme change monitoring
   */
  setupThemeMonitoring() {
    const reducedMotionQuery = window.matchMedia?.(
      '(prefers-reduced-motion: reduce)'
    );
    const highContrastQuery = window.matchMedia?.('(prefers-contrast: high)');

    const handleThemeChange = () => {
      // Get current saved preferences to check which ones are user-set
      const savedPreferences = userPreferences.getAccessibilitySettings();

      // Only update preferences that haven't been explicitly set by the user
      const newPreferences = { ...this.preferences };

      // Update system-based preferences only if user hasn't overridden them
      if (savedPreferences.reducedMotion === undefined) {
        newPreferences.reducedMotion = reducedMotionQuery?.matches || false;
      }
      if (savedPreferences.highContrast === undefined) {
        newPreferences.highContrast = highContrastQuery?.matches || false;
      }
      // largeText is always user-controlled, so never auto-update it

      if (JSON.stringify(newPreferences) !== JSON.stringify(this.preferences)) {
        this.preferences = newPreferences;
        this.currentTheme = newPreferences.highContrast
          ? 'high-contrast'
          : 'light';
        this.applyTheme();
        this.announceThemeChange();

        AppDebug.log(
          'System theme changed, updated non-user-set preferences:',
          newPreferences
        );
      }
    };

    reducedMotionQuery?.addEventListener?.('change', handleThemeChange);
    highContrastQuery?.addEventListener?.('change', handleThemeChange);
  }

  /**
   * Apply current theme to the application
   */
  applyTheme() {
    const { body } = document;

    // Remove existing theme classes
    body.classList.remove('high-contrast', 'reduced-motion', 'large-text');

    // Apply current theme classes
    if (this.preferences.highContrast) body.classList.add('high-contrast');
    if (this.preferences.reducedMotion) body.classList.add('reduced-motion');
    if (this.preferences.largeText) body.classList.add('large-text');

    // Update button states (aria-pressed attributes)
    this.updateButtonStates();

    // Update theme color meta tag
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    if (themeColorMeta) {
      const themeColor = '#1a73e8'; // Always use light theme color
      themeColorMeta.setAttribute('content', themeColor);
    }

    // Update managers if they exist
    if (this.animationManager) {
      // Update the animation manager theme when preferences change
      this.animationManager.updateAnimationDefaults();
    }

    if (this.accessibilityManager) {
      this.accessibilityManager.updateTheme(this.preferences);
    }
  }

  /**
   * Update accessibility button states
   */
  updateButtonStates() {
    const highContrastBtn = document.getElementById('toggle-high-contrast');
    const largeTextBtn = document.getElementById('toggle-large-text');
    const reducedMotionBtn = document.getElementById('toggle-reduced-motion');

    if (highContrastBtn) {
      highContrastBtn.setAttribute(
        'aria-pressed',
        this.preferences.highContrast.toString()
      );
    }
    if (largeTextBtn) {
      largeTextBtn.setAttribute(
        'aria-pressed',
        this.preferences.largeText.toString()
      );
    }
    if (reducedMotionBtn) {
      reducedMotionBtn.setAttribute(
        'aria-pressed',
        this.preferences.reducedMotion.toString()
      );
    }
  }

  /**
   * Announce theme changes for accessibility
   */
  announceThemeChange() {
    const announcement = `Theme changed to ${this.currentTheme.replace('-', ' ')} mode`;

    if (this.accessibilityManager) {
      this.accessibilityManager.announce(announcement);
    } else {
      // Fallback announcement
      const liveRegion = document.getElementById('aria-live-polite');
      if (liveRegion) {
        liveRegion.textContent = announcement;
      }
    }
  }

  /**
   * Initialize error handling and recovery
   */
  initializeErrorHandling() {
    // Create error boundary element
    this.errorBoundary = document.getElementById('error-boundary');

    // Global error handlers
    window.addEventListener('error', event => {
      this.handleError(event.error, 'A JavaScript error occurred');
    });

    window.addEventListener('unhandledrejection', event => {
      this.handleError(event.reason, 'An unhandled promise rejection occurred');
    });

    AppDebug.log('Error handling initialized');
  }

  /**
   * Enhanced error handling with recovery options
   */
  handleError(error, userMessage = 'An unexpected error occurred') {
    this.lastError = error;
    AppDebug.error('App Error:', error);

    // Track error for analytics
    simpleAnalytics.trackEvent('app_error', {
      error_message: error.message || String(error),
      error_stack: error.stack,
      user_agent: navigator.userAgent,
      timestamp: new Date().toISOString(),
    });

    // Show error to user
    this.showError(userMessage);

    // Announce error for accessibility
    if (this.accessibilityManager) {
      this.accessibilityManager.announce(`Error: ${userMessage}`, 'assertive');
    }
  }

  /**
   * Show error in error boundary
   */
  showError(message, isRecoverable = true) {
    if (!this.errorBoundary) {
      // Fallback to alert if no error boundary
      alert(message);
      return;
    }

    const errorContent = this.errorBoundary.querySelector('.error-content');
    if (errorContent) {
      const messageEl = errorContent.querySelector('.error-message');
      const retryBtn = errorContent.querySelector('#retry-action');
      const reportBtn = errorContent.querySelector('#report-error');

      if (messageEl) messageEl.textContent = message;

      // Setup retry functionality
      if (retryBtn && isRecoverable) {
        retryBtn.style.display = 'inline-block';
        retryBtn.onclick = () => {
          this.hideError();
          // Attempt to recover by reinitializing
          if (!this.isInitialized) {
            this.init();
          }
        };
      } else if (retryBtn) {
        retryBtn.style.display = 'none';
      }

      // Setup error reporting
      if (reportBtn) {
        reportBtn.onclick = () => {
          this.reportError();
        };
      }
    }

    this.errorBoundary.setAttribute('aria-hidden', 'false');
    this.errorBoundary.style.display = 'flex';
  }

  /**
   * Hide error boundary
   */
  hideError() {
    if (this.errorBoundary) {
      this.errorBoundary.setAttribute('aria-hidden', 'true');
      this.errorBoundary.style.display = 'none';
    }
  }

  /**
   * Report error to analytics/support
   */
  reportError() {
    if (this.lastError) {
      const errorReport = {
        message: this.lastError.message || String(this.lastError),
        stack: this.lastError.stack,
        userAgent: navigator.userAgent,
        url: window.location.href,
        timestamp: new Date().toISOString(),
        appState: {
          initialized: this.isInitialized,
          currentSimulation: this.currentSimulation?.id,
          theme: this.currentTheme,
        },
      };

      // Send to analytics
      simpleAnalytics.trackEvent('error_reported', errorReport);

      // Show confirmation
      alert(
        'Error report sent. Thank you for helping us improve the application.'
      );
    }
  }

  async initializeSystems() {
    try {
      // Initialize animation manager with theme preferences
      this.animationManager = new AnimationManager({
        enableAnimations: !this.preferences.reducedMotion,
        reducedMotion: this.preferences.reducedMotion,
        performanceMode: this.preferences.reducedMotion
          ? 'compatibility'
          : 'balanced',
      });

      // Initialize accessibility manager with current preferences
      this.accessibilityManager = new AccessibilityManager(document.body, {
        theme: this.currentTheme,
        preferences: this.preferences,
      });

      // Initialize core educational modules
      await this.initializeCoreModules();

      // Visual Engine will be initialized later when we have canvas elements
      // Just store the configuration for now
      this.visualEngineConfig = {
        renderMode: 'canvas',
        accessibility: true,
        highPerformance: !this.preferences.reducedMotion,
        debug: false,
        highContrast: this.preferences.highContrast,
        reducedMotion: this.preferences.reducedMotion,
      };

      // Systems are already initialized via their modules
      // Simple analytics auto-initializes
      AppDebug.log('Core systems initialized with modernized infrastructure');
    } catch (error) {
      AppDebug.error('Failed to initialize systems:', error);
      throw error;
    }
  }

  /**
   * Initialize core educational modules
   */
  async initializeCoreModules() {
    try {
      // Initialize Educator Toolkit
      this.educatorToolkit = new EducatorToolkit();
      AppDebug.log('Educator Toolkit initialized');

      // Initialize Digital Science Lab
      this.digitalScienceLab = new DigitalScienceLab();
      AppDebug.log('Digital Science Lab initialized');

      // Initialize Scenario Generator
      this.scenarioGenerator = new ScenarioGenerator();
      AppDebug.log('Scenario Generator initialized');

      // Connect the modules for integrated functionality
      this.connectEducationalModules();
    } catch (error) {
      AppDebug.error('Failed to initialize core educational modules:', error);
      throw error;
    }
  }

  /**
   * Connect educational modules for integrated functionality
   */
  connectEducationalModules() {
    // Connect scenario generator to educator toolkit for assessment alignment
    if (this.educatorToolkit && this.scenarioGenerator) {
      this.educatorToolkit.setScenarioGenerator(this.scenarioGenerator);
    }

    // Connect digital science lab to both toolkit and generator
    if (this.digitalScienceLab) {
      if (this.educatorToolkit) {
        this.digitalScienceLab.setEducatorToolkit(this.educatorToolkit);
      }
      if (this.scenarioGenerator) {
        this.digitalScienceLab.setScenarioGenerator(this.scenarioGenerator);
      }
    }

    AppDebug.log('Educational modules connected successfully');
  }

  /**
   * Connect core educational modules to a simulation instance
   * @param {Object} simulation - The simulation instance
   * @param {Object} config - The simulation configuration
   */
  connectModulesToSimulation(simulation, config) {
    try {
      // Connect Educator Toolkit
      if (this.educatorToolkit && simulation) {
        simulation.educatorToolkit = this.educatorToolkit;

        // Get curriculum alignment for this simulation
        const curriculumAlignment = this.educatorToolkit.getCurriculumAlignment(
          config.tags || []
        );
        if (curriculumAlignment) {
          simulation.curriculumAlignment = curriculumAlignment;
        }

        // Get assessment tools for this simulation
        const assessmentTools = this.educatorToolkit.getAssessmentTools(
          config.difficulty
        );
        if (assessmentTools) {
          simulation.assessmentTools = assessmentTools;
        }
      }

      // Connect Digital Science Lab
      if (this.digitalScienceLab && simulation) {
        simulation.digitalScienceLab = this.digitalScienceLab;

        // Get relevant lab stations for this simulation
        const relevantStations = this.digitalScienceLab.getRelevantStations(
          config.tags || []
        );
        if (relevantStations) {
          simulation.labStations = relevantStations;
        }
      }

      // Connect Scenario Generator
      if (this.scenarioGenerator && simulation) {
        simulation.scenarioGenerator = this.scenarioGenerator;

        // If this simulation can use generated scenarios, provide them
        if (simulation.supportsGeneratedScenarios) {
          const generatedScenarios = this.scenarioGenerator.generateScenarios(
            config.tags?.[0] || 'general',
            config.difficulty || 'beginner'
          );
          if (generatedScenarios) {
            simulation.generatedScenarios = generatedScenarios;
          }
        }
      }

      AppDebug.log(
        `Educational modules connected to simulation: ${simulation.id || 'unknown'}`
      );
    } catch (error) {
      AppDebug.error(
        'Failed to connect educational modules to simulation:',
        error
      );
      // Non-critical error - simulation can still function without full integration
    }
  }

  setupUI() {
    // Get key UI elements
    this.modal = document.getElementById('simulation-modal');
    this.simulationContainer = document.getElementById('simulation-container');
    this.categoriesGrid = document.querySelector(
      '.categories-grid, .simulations-grid'
    );
    this.loading = document.getElementById('loading');

    if (!this.categoriesGrid) {
      AppDebug.error('Categories grid not found');
      return;
    }

    // Initialize CategoryGrid
    this.initializeCategoryGrid();
  }

  /**
   * Initialize the new category grid system
   */
  initializeCategoryGrid() {
    try {
      this.categoryGrid = new CategoryGrid();
      AppDebug.log('Category grid initialized successfully');
    } catch (error) {
      AppDebug.error('Failed to initialize category grid:', error);
      // Fallback to legacy simulation loading if category grid fails
      this.loadLegacySimulations();
    }
  }

  /**
   * Fallback method for legacy simulation loading
   */
  loadLegacySimulations() {
    AppDebug.log('Loading legacy simulation cards as fallback');
    // This will be populated with existing simulation loading logic if needed
    // For now, just log that we're in fallback mode
  }

  async loadSimulations() {
    // Simulations are loaded dynamically in createSimulationInstance()
    // Store available simulation configs in the simulations Map
    this.availableSimulations.forEach(simConfig => {
      this.simulations.set(simConfig.id, simConfig);
    });
  }

  /**
   * Initialize hero demo component
   * Currently using radar chart demo instead of HeroDemo class
   */
  async initializeHeroDemo() {
    // The HeroDemo class is designed for a different hero layout
    // that's not currently implemented. The radar chart demo is working fine.
    logger.info(
      'App',
      'Hero demo: Using radar chart demo instead of HeroDemo class'
    );
  }

  /**
   * Initialize enhanced objects (visual components)
   */
  async initializeEnhancedObjects() {
    try {
      // Enhanced objects are loaded dynamically when needed
      // This method is kept for future initialization if needed
      logger.info('App', 'Enhanced objects system ready for dynamic loading');
    } catch (error) {
      logger.error('Failed to initialize enhanced objects:', error);
      // Non-critical error - app can continue with basic functionality
    }
  }

  /**
   * Initialize modal footer management system
   */
  initializeModalFooterManager() {
    try {
      // Initialize the modal footer manager
      this.modalFooterManager = new ModalFooterManager();

      // Store reference for cleanup
      this.modalFooterManager.app = this;

      logger.info('App', 'Modal footer manager initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize modal footer manager:', error);
      // Non-critical error - modals will still work with basic functionality
    }
  }

  /**
   * Initialize ethics radar demo system
   */
  async initializeEthicsRadarDemo() {
    try {
      // Only initialize if the hero demo container exists
      const demoContainer = document.getElementById('hero-ethics-chart');
      if (demoContainer) {
        // Initialize the ethics radar demo
        ethicsDemo = new EthicsRadarDemo();

        logger.info('App', 'Ethics radar demo initialized successfully');
      } else {
        logger.warn(
          'Hero ethics chart container not found, skipping radar demo initialization'
        );
      }
    } catch (error) {
      logger.error('Failed to initialize ethics radar demo:', error);
      // Non-critical error - the demo is optional
    }
  }

  setupEventListeners() {
    // Mobile navigation functionality
    this.setupMobileNavigation();

    // Surprise Me functionality
    this.setupSurpriseMe();

    // Tour functionality
    this.setupTourButton();

    // Hero section buttons
    const startLearningBtn = document.getElementById('start-learning');

    if (startLearningBtn) {
      startLearningBtn.addEventListener('click', () => {
        this.scrollToSimulations();
      });
    }

    // Debug: Test scenario modal button
    const testScenarioBtn = document.getElementById('test-scenario-modal');
    if (testScenarioBtn) {
      testScenarioBtn.addEventListener('click', () => {
        this.testScenarioModal();
      });
    }

    // Modal controls
    if (this.modal) {
      const closeBtn = this.modal.querySelector('.modal-close');
      const resetBtn = document.getElementById('reset-simulation');
      const nextBtn = document.getElementById('next-scenario');

      if (closeBtn) {
        closeBtn.addEventListener('click', () => this.closeSimulation());

        // Add focus trapping to the modal
        this.modal.addEventListener('keydown', e => {
          if (e.key === 'Tab') {
            this.trapFocusInModal(e);
          }
        });
      }

      if (resetBtn) {
        resetBtn.addEventListener('click', () => this.resetCurrentSimulation());
      }

      if (nextBtn) {
        nextBtn.addEventListener('click', () => this.nextScenario());
      }

      // Close modal on backdrop click
      this.modal.addEventListener('click', e => {
        if (e.target === this.modal) {
          this.closeSimulation();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !this.modal.hasAttribute('aria-hidden')) {
          this.closeSimulation();
        }
      });
    }

    // Enhanced simulation card buttons (delegated event handling)
    document.addEventListener('click', e => {
      if (e.target.classList.contains('enhanced-sim-button')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Learning Lab button - go through pre-launch modal
          this.startSimulation.call(this, simulationId);
        }
      } else if (e.target.classList.contains('simulation-quick-start-btn')) {
        e.preventDefault();
        const simulationId = e.target.getAttribute('data-simulation');
        if (simulationId) {
          // Quick start button - skip pre-launch modal
          this.launchSimulationDirect.call(this, simulationId);
        }
      }
    });
  }

  /**
   * Simulation management - Two-stage launch flow
   */
  async startSimulation(simulationId) {
    try {
      // Verify 'this' context is correct
      if (!this || typeof this.showNotification !== 'function') {
        throw new Error(
          'App context not properly bound. startSimulation called with wrong context.'
        );
      }

      // Check if we should show the pre-launch modal first
      const shouldShowPreLaunch =
        !userPreferences.shouldSkipPreLaunch(simulationId);

      if (shouldShowPreLaunch) {
        this.showPreLaunchModal(simulationId);
        return; // Pre-launch modal will call launchSimulationDirect when ready
      }

      // Direct launch (skipping pre-launch modal)
      await this.launchSimulationDirect(simulationId);
    } catch (error) {
      AppDebug.error('Failed to start simulation:', error);
      this.hideLoading();

      // Use fallback notification if this.showNotification is not available
      if (typeof this.showNotification === 'function') {
        this.showNotification(
          'Failed to start simulation. Please try again.',
          'error'
        );
      } else {
        // Fallback to logger and direct notification system
        logger.error('Failed to start simulation:', error.message);
        if (window.NotificationToast) {
          window.NotificationToast.show({
            type: 'error',
            message: 'Failed to start simulation. Please try again.',
            duration: 5000,
            closable: true,
          });
        }
      }
    }
  }

  /**
   * Clean up any existing modal instances to prevent multiple modals
   */
  cleanupExistingModals() {
    // Close any existing pre-launch modals by backdrop
    const existingModalBackdrops = document.querySelectorAll('.modal-backdrop');
    existingModalBackdrops.forEach(backdrop => {
      const modalDialog = backdrop.querySelector('.modal-dialog');
      if (modalDialog && modalDialog.querySelector('.pre-launch-modal')) {
        // Found a pre-launch modal, remove it immediately
        backdrop.remove();
      }
    });

    // Also clean up any orphaned modal elements
    const orphanedPreLaunchModals =
      document.querySelectorAll('.pre-launch-modal');
    orphanedPreLaunchModals.forEach(modal => {
      const parentBackdrop = modal.closest('.modal-backdrop');
      if (parentBackdrop) {
        parentBackdrop.remove();
      } else {
        modal.remove();
      }
    });

    // Clean up body styles that might be left behind
    document.body.style.overflow = '';

    // Remove any modal-related classes from body
    document.body.classList.remove('modal-open');

    // Remove any lingering inert states from other elements
    document.querySelectorAll('[inert]').forEach(el => {
      if (!el.classList.contains('modal-backdrop')) {
        el.removeAttribute('inert');
      }
    });
  }

  /**
   * Shows the pre-launch information modal
   */
  showPreLaunchModal(simulationId) {
    logger.debug('Showing pre-launch modal for:', simulationId);

    // Clean up any existing modals first
    this.cleanupExistingModals();

    const prelaunchModal = new PreLaunchModal(simulationId, {
      onLaunch: id => {
        logger.debug('Pre-launch modal onLaunch called with:', id);
        // User clicked "Start Exploration" - proceed with simulation
        this.launchSimulationDirect(id || simulationId);
      },
      onCancel: () => {
        logger.debug('Pre-launch modal cancelled');
        // User clicked "Maybe Later" - just close modal
        this.hideLoading();
      },
      showEducatorResources: true, // Always show educator resources
    });

    prelaunchModal.show();
  }

  /**
   * Direct simulation launch (bypasses pre-launch modal)
   */
  async launchSimulationDirect(simulationId) {
    try {
      this.showLoading();

      // Cleanup previous simulation canvases and engines
      if (this.currentSimulation && this.currentSimulation.cleanup) {
        this.currentSimulation.cleanup();
      }

      // Cleanup any existing simulation canvas
      if (this.currentSimulationCanvasId) {
        canvasManager.removeCanvas(this.currentSimulationCanvasId);
        this.currentSimulationCanvasId = null;
      }

      // Cleanup hero demo canvas if running
      if (this.heroDemoCanvasId) {
        canvasManager.removeCanvas(this.heroDemoCanvasId);
        this.heroDemoCanvasId = null;
      }

      const simConfig = this.simulations.get(simulationId);
      if (!simConfig) {
        throw new Error(`Simulation ${simulationId} not found`);
      }

      // Track simulation start
      simpleAnalytics.trackSimulationStart(simulationId, simConfig.title); // Get simulation container
      const simulationContainer = document.getElementById(
        'simulation-container'
      );
      if (!simulationContainer) {
        throw new Error('Simulation container not found');
      }

      // Add loading state to container
      simulationContainer.classList.add('loading');
      simulationContainer.setAttribute('aria-busy', 'true');
      simulationContainer.setAttribute(
        'aria-label',
        `Loading ${simConfig.title} simulation`
      );

      // Clear previous content and remove any error states
      simulationContainer.innerHTML = '';
      simulationContainer.classList.remove('error');
      // Create managed canvas for the simulation
      const { canvas, id } = await canvasManager.createCanvas({
        width: 600,
        height: 400,
        container: simulationContainer,
        className: 'simulation-canvas',
        id: `simulation-${simulationId}`,
      });

      // Store canvas ID for cleanup
      this.currentSimulationCanvasId = id;

      // Check if simulation needs canvas or is HTML-only
      if (simConfig.useCanvas !== false && simConfig.renderMode !== 'html') {
        // Apply responsive styling to canvas
        canvas.style.cssText = `
                    max-width: 100%;
                    max-height: 100%;
                    width: auto;
                    height: auto;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    background: #fff;
                `;

        // Create visual engine using canvas manager
        this.engine = await canvasManager.createVisualEngine(id, {
          renderMode: 'canvas',
          accessibility: true,
          debug: false,
          width: 600,
          height: 400,
        });

        // Set the container reference on the engine for simulation compatibility
        this.engine.container = simulationContainer;
      } else {
        // For HTML-only simulations, create a simple mock engine with just the container
        this.engine = {
          container: simulationContainer,
          type: 'html',
          renderMode: 'html',
          start: () => {
            // Mock engine started for HTML simulation
          },
          stop: () => {
            // Mock engine stopped for HTML simulation
          },
          destroy: () => {
            // Mock engine destroyed for HTML simulation
          },
        };

        // Remove the canvas element since it's not needed
        if (canvas && canvas.parentNode) {
          canvas.parentNode.removeChild(canvas);
        }
      }

      // Create the specific simulation instance
      this.currentSimulation = await this.createSimulationInstance(
        simulationId,
        simConfig
      );

      if (!this.currentSimulation) {
        throw new Error('Failed to create simulation instance');
      }

      // Initialize the simulation
      this.currentSimulation.init(this.engine);

      // Setup simulation event listeners
      this.setupSimulationEventListeners();

      // Show the enhanced simulation modal instead of the basic modal
      this.showEnhancedSimulationModal(simulationId, simConfig);

      // Start the engine
      this.engine.start();
      // Start the simulation
      this.currentSimulation.start();

      this.hideLoading();
      // Remove loading state from container
      if (simulationContainer) {
        simulationContainer.classList.remove('loading');
        simulationContainer.removeAttribute('aria-busy');
        simulationContainer.setAttribute(
          'aria-label',
          `${simConfig.title} simulation`
        );
      }

      logger.debug('Simulation launched successfully');
    } catch (error) {
      AppDebug.error('Failed to start simulation:', error);
      this.hideLoading();

      // Add error state to container
      const simulationContainer = document.getElementById(
        'simulation-container'
      );
      if (simulationContainer) {
        simulationContainer.classList.remove('loading');
        simulationContainer.classList.add('error');
        simulationContainer.removeAttribute('aria-busy');
        simulationContainer.setAttribute(
          'aria-label',
          'Simulation failed to load'
        );
        simulationContainer.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <h3>Simulation Failed to Load</h3>
                        <p>There was an error loading the simulation. Please try again.</p>
                        <button class="btn btn-primary" onclick="this.closest('.modal').querySelector('.modal-close').click()">Close</button>
                    </div>
                `;
      }

      this.showError('Failed to start the simulation. Please try again.');
    }
  }

  async createSimulationInstance(simulationId, config) {
    try {
      let simulation;

      // Load the specific simulation class based on ID
      switch (simulationId) {
        /* Temporarily disabled - missing simulation file
        case 'bias-fairness': {
          const { default: BiasExplorerSimulation } = await import(
            './simulations/bias-fairness-v2.js'
          );
          simulation = new BiasExplorerSimulation(simulationId);
          // Set container reference
          simulation.container = document.getElementById(
            'simulation-container'
          );
          break;
        }
        */

        default: {
          // Fallback to basic simulation for unimplemented simulations
          const basicScenarios = [
            {
              id: 'intro',
              title: 'Introduction',
              description:
                'Welcome to this open-ended exploration of AI ethics',
              objective:
                'Explore different perspectives and discover consequences of choices',
            },
            {
              id: 'decision1',
              title: 'First Decision',
              description: 'Make your first ethical choice',
              objective: 'Choose the most ethical option',
            },
            {
              id: 'conclusion',
              title: 'Conclusion',
              description: 'Reflect on your decisions',
              objective: 'Review your ethical choices',
            },
          ];

          simulation = new EthicsSimulation(simulationId, {
            title: config.title,
            description: config.description,
            difficulty: config.difficulty,
            duration: config.duration,
            scenarios: basicScenarios,
            ethicsMetrics: [
              {
                name: 'fairness',
                label: 'Fairness',
                value: APP_CONSTANTS.DEFAULTS.ETHICS_METER_VALUE,
              },
              {
                name: 'transparency',
                label: 'Transparency',
                value: APP_CONSTANTS.DEFAULTS.ETHICS_METER_VALUE,
              },
              {
                name: 'privacy',
                label: 'Privacy',
                value: APP_CONSTANTS.DEFAULTS.ETHICS_METER_VALUE,
              },
            ],
          });

          // Set container reference
          simulation.container = document.getElementById(
            'simulation-container'
          );
          break;
        }
      }

      // Connect core educational modules to the simulation
      if (simulation) {
        this.connectModulesToSimulation(simulation, config);
      }

      return simulation;
    } catch (error) {
      AppDebug.error(`Failed to load simulation ${simulationId}:`, error);
      throw error;
    }
  }

  setupSimulationEventListeners() {
    if (!this.currentSimulation) return;

    this.currentSimulation.on('simulation:completed', data => {
      this.onSimulationCompleted(data);
    });

    this.currentSimulation.on('ethics:updated', data => {
      // Handle ethics updates
      AppDebug.log('Ethics updated:', data);
    });

    this.currentSimulation.on('scenario:loaded', data => {
      // Update UI for new scenario
      this.updateModalTitle(data.scenario.title);
    });
  }

  /**
   * Handle simulation completion - show post-simulation modal
   */
  onSimulationCompleted(data) {
    AppDebug.log('Simulation completed:', data);

    try {
      // Close the enhanced simulation modal first
      const enhancedModal = document.querySelector(
        '.enhanced-simulation-modal'
      );
      if (enhancedModal) {
        enhancedModal.style.display = 'none';
        enhancedModal.setAttribute('aria-hidden', 'true');
      }

      // Track simulation completion
      if (this.currentSimulation && this.currentSimulation.id) {
        simpleAnalytics.trackSimulationComplete(
          this.currentSimulation.id,
          data
        );
      }

      // Show post-simulation modal
      this.showPostSimulationModal(data);
    } catch (error) {
      AppDebug.error('Error handling simulation completion:', error);
      // Fallback to basic completion handling
      this.hideModal();
      this.showNotification(
        'Simulation completed! Thank you for exploring AI Ethics.',
        'success'
      );
    }
  }

  /**
   * Show the post-simulation reflection modal
   */
  showPostSimulationModal(data) {
    const simulationId = this.currentSimulation?.id || 'unknown';

    const postModal = new PostSimulationModal(simulationId, {
      sessionData: data,
      onComplete: () => {
        // User finished reflection - close modal and return to main view
        this.hideModal();
        this.showNotification(
          'Thank you for your thoughtful reflection!',
          'success'
        );
      },
      onSkip: () => {
        // User skipped reflection - just close modal
        this.hideModal();
      },
      onRestart: () => {
        // User wants to restart simulation
        this.hideModal();
        this.startSimulation(simulationId);
      },
    });

    postModal.show();
  }

  /**
   * Show the enhanced simulation modal for the active simulation
   */
  showEnhancedSimulationModal(simulationId, simConfig) {
    AppDebug.log('Showing enhanced simulation modal for:', simulationId);

    try {
      // Configure modal options based on simulation type
      const modalOptions = {
        simulation: this.currentSimulation,
        onClose: () => {
          AppDebug.log('Enhanced modal closed');
          this.enhancedModal = null;
          this.hideModal();
        },
        onMinimize: () => {
          AppDebug.log('Enhanced modal minimized');
          // Keep simulation running but minimize UI
        },
      };

      // For bias-fairness simulation, optimize for content space
      if (simulationId === 'bias-fairness') {
        modalOptions.showResourcePanel = false; // Hide resource panel by default
        modalOptions.collapseEthicsMeters = true; // Hide ethics meters
        modalOptions.showTabs = false; // Hide tabs for cleaner interface
        modalOptions.size = 'large'; // Use large size for more space
      }

      this.enhancedModal = new EnhancedSimulationModal(
        simulationId,
        modalOptions
      );

      this.enhancedModal.show();

      // CRITICAL: Connect the simulation to the enhanced modal's container
      setTimeout(() => {
        const enhancedContainer = this.enhancedModal.getSimulationContainer();
        if (enhancedContainer && this.currentSimulation) {
          AppDebug.log('Moving simulation to enhanced modal container');

          // Get the original simulation container content
          const originalContainer = document.getElementById(
            'simulation-container'
          );
          if (originalContainer) {
            // Move all content from original container to enhanced container
            while (originalContainer.firstChild) {
              enhancedContainer.appendChild(originalContainer.firstChild);
            }

            // Update the simulation's container reference
            if (this.engine) {
              this.engine.container = enhancedContainer;
            }

            // If the simulation has a container property, update it
            if (this.currentSimulation.container) {
              this.currentSimulation.container = enhancedContainer;
            }

            // Re-setup the simulation UI in the new container
            if (this.currentSimulation.setupUI) {
              this.currentSimulation.setupUI();
            }
          }
        }
      }, 100); // Small delay to ensure modal is fully created
    } catch (error) {
      AppDebug.error('Failed to show enhanced simulation modal:', error);
      // Fallback to basic modal
      this.showSimulationModal(simConfig);
    }
  }

  showSimulationModal(simConfig) {
    if (!this.modal) return;

    const title = this.modal.querySelector('#modal-title');
    if (title) {
      title.textContent = simConfig.title;
    }

    // Store the currently focused element to restore later
    this.lastFocusedElement = document.activeElement;

    // Remove inert from modal and set aria-hidden to false
    this.modal.removeAttribute('inert');
    this.modal.setAttribute('aria-hidden', 'false');
    this.modal.style.display = 'flex';

    // Add visible class for CSS opacity transition
    requestAnimationFrame(() => {
      this.modal.classList.add('visible');
    });

    // Make background content inert
    const mainContent = document.getElementById('main-content');
    if (mainContent) {
      mainContent.setAttribute('inert', '');
    }

    // Focus management - focus the close button initially
    const closeButton = this.modal.querySelector('.modal-close');
    if (closeButton) {
      closeButton.focus();
    }
  }

  /**
   * Trap focus within modal for accessibility
   */
  trapFocusInModal(event) {
    if (!this.modal || this.modal.hasAttribute('aria-hidden')) return;

    const focusableElements = this.modal.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );

    const firstFocusable = focusableElements[0];
    const lastFocusable = focusableElements[focusableElements.length - 1];

    if (event.shiftKey) {
      // Shift + Tab
      if (document.activeElement === firstFocusable) {
        lastFocusable.focus();
        event.preventDefault();
      }
    } else {
      // Tab
      if (document.activeElement === lastFocusable) {
        firstFocusable.focus();
        event.preventDefault();
      }
    }
  }

  closeSimulation() {
    if (this.currentSimulation) {
      this.currentSimulation.reset();
      this.currentSimulation = null;
    }

    if (this.engine) {
      this.engine.stop();
      this.engine.destroy();
      this.engine = null;
    }

    // Cleanup all managed canvases
    const canvasesToCleanup = [
      this.currentSimulationCanvasId,
      this.ethicsMetersCanvasId,
      this.interactiveButtonsCanvasId,
      this.simulationSlidersCanvasId,
    ];

    canvasesToCleanup.forEach(canvasId => {
      if (canvasId) {
        canvasManager.removeCanvas(canvasId);
      }
    });

    // Reset canvas IDs
    this.currentSimulationCanvasId = null;
    this.ethicsMetersCanvasId = null;
    this.interactiveButtonsCanvasId = null;
    this.simulationSlidersCanvasId = null;
    if (this.modal) {
      // Remove focus from any focused elements inside the modal first
      const focusedElement = this.modal.querySelector(':focus');
      if (focusedElement) {
        focusedElement.blur();
      }

      // Restore focus to the element that was focused before the modal opened
      if (
        this.lastFocusedElement &&
        document.contains(this.lastFocusedElement)
      ) {
        this.lastFocusedElement.focus();
      }

      // Make modal inert and hide it
      this.modal.setAttribute('inert', '');
      this.modal.setAttribute('aria-hidden', 'true');
      this.modal.classList.remove('visible');
      this.modal.style.display = 'none';

      // Remove inert from main content
      const mainContent = document.getElementById('main-content');
      if (mainContent) {
        mainContent.removeAttribute('inert');
      }
    } // Clear simulation container
    if (this.simulationContainer) {
      this.simulationContainer.innerHTML = '';
      this.simulationContainer.classList.remove('loading', 'error');
      this.simulationContainer.removeAttribute('aria-busy');
      this.simulationContainer.removeAttribute('aria-label');
    }
  }

  /**
   * Resets the current simulation
   */
  resetCurrentSimulation() {
    if (this.currentSimulation && this.currentSimulation.reset) {
      this.currentSimulation.reset();
    }
  }

  /**
   * Shows the loading indicator
   */
  showLoading() {
    if (this.loading) {
      this.loading.style.display = 'flex';
      this.loading.setAttribute('aria-hidden', 'false');
    }
  }

  /**
   * Hides the loading indicator
   */
  hideLoading() {
    if (this.loading) {
      this.loading.style.display = 'none';
      this.loading.setAttribute('aria-hidden', 'true');
    }
  }

  /**
   * Toggles simulation pause state
   */
  toggleSimulationPause(isPaused) {
    if (this.currentSimulation) {
      if (isPaused && this.currentSimulation.pause) {
        this.currentSimulation.pause();
      } else if (!isPaused && this.currentSimulation.resume) {
        this.currentSimulation.resume();
      }
    }
  }

  /**
   * Populates the enhanced modal with simulation-specific data
   */
  async populateEnhancedModalData(simulationId) {
    try {
      // Import simulation data
      const { simulationData } = await import('./data/simulation-info.js');
      const simData = simulationData[simulationId];

      if (!simData) {
        AppDebug.warn(`No simulation data found for ${simulationId}`);
        return;
      }

      // Populate resource tab
      this.populateResourcesTab(simData);

      // Populate help tab
      this.populateHelpTab(simData);

      // Populate quick resources panel
      this.populateQuickResourcesPanel(simData);
    } catch (error) {
      AppDebug.error('Failed to populate enhanced modal data:', error);
    }
  }

  /**
   * Populates the resources tab with simulation data
   */
  populateResourcesTab(simData) {
    if (!this.currentEnhancedModal) return;

    const { modal } = this.currentEnhancedModal;
    if (!modal) return;

    // Background reading
    const readingContainer = modal.querySelector('#background-reading');
    if (readingContainer && simData.resources?.backgroundReading) {
      readingContainer.innerHTML = simData.resources.backgroundReading
        .map(
          resource => `
                <div class="resource-item">
                    <a href="${resource.url}" target="_blank" class="resource-title">${resource.title}</a>
                    <p class="resource-description">${resource.description}</p>
                </div>
            `
        )
        .join('');
    }

    // Related videos
    const videosContainer = modal.querySelector('#related-videos');
    if (videosContainer && simData.resources?.videos) {
      videosContainer.innerHTML = simData.resources.videos
        .map(
          video => `
                <div class="resource-item">
                    <a href="${video.url}" target="_blank" class="resource-title">${video.title}</a>
                    <p class="resource-description">${video.description}</p>
                    <span class="resource-duration">${video.duration}</span>
                </div>
            `
        )
        .join('');
    }

    // Discussion questions
    const questionsContainer = modal.querySelector('#discussion-questions');
    if (questionsContainer && simData.educatorResources?.discussionQuestions) {
      questionsContainer.innerHTML =
        simData.educatorResources.discussionQuestions
          .map(
            question => `
                <div class="resource-item">
                    <p class="discussion-question">${question}</p>
                </div>
            `
          )
          .join('');
    }
  }

  /**
   * Populates the help tab with simulation-specific information
   */
  populateHelpTab(simData) {
    if (!this.currentEnhancedModal) return;

    const { modal } = this.currentEnhancedModal;
    if (!modal) return;

    // Ethics explanation
    const ethicsContainer = modal.querySelector('#ethics-explanation');
    if (ethicsContainer && simData.vocabulary) {
      ethicsContainer.innerHTML = Object.entries(simData.vocabulary)
        .map(
          ([term, definition]) => `
                <div class="ethics-term">
                    <h5>${term}</h5>
                    <p>${definition}</p>
                </div>
            `
        )
        .join('');
    }
  }

  /**
   * Populates the quick resources panel
   */
  populateQuickResourcesPanel(simData) {
    if (!this.currentEnhancedModal) return;

    const { modal } = this.currentEnhancedModal;
    if (!modal) return;

    // Quick concepts
    const conceptsContainer = modal.querySelector('#quick-concepts');
    if (conceptsContainer && simData.vocabulary) {
      const MAX_QUICK_TERMS = 5;
      const keyTerms = Object.keys(simData.vocabulary).slice(
        0,
        MAX_QUICK_TERMS
      );
      conceptsContainer.innerHTML = keyTerms
        .map(
          term => `
                <li><a href="#" class="resource-link" data-term="${term}">${term}</a></li>
            `
        )
        .join('');

      // Add click handlers for terms
      conceptsContainer.querySelectorAll('[data-term]').forEach(link => {
        link.addEventListener('click', e => {
          e.preventDefault();
          const {
            dataset: { term },
          } = e.target;
          const definition = simData.vocabulary[term];
          this.showQuickHelp(term, definition);
        });
      });
    }
  }

  /**
   * Shows quick help tooltip or modal
   */
  showQuickHelp(term, definition) {
    // Create a simple tooltip or notification
    const NOTIFICATION_DURATION = 5000;
    this.showNotification(
      `${term}: ${definition}`,
      'info',
      NOTIFICATION_DURATION
    );
  }

  /**
   * Shows a notification toast message
   * @param {string} message - The notification message
   * @param {string} type - The notification type ('success', 'error', 'warning', 'info')
   * @param {number} duration - Auto-dismiss duration in ms (optional)
   * @returns {string|null} - Toast ID or null if failed
   */
  showNotification(message, type = 'info', duration = 5000) {
    if (window.NotificationToast) {
      // Use the global notification toast instance
      return window.NotificationToast.show({
        type,
        message,
        duration,
        closable: true,
      });
    } else {
      // Fallback to logger if notification system not available
      logger.info(`[${type.toUpperCase()}] ${message}`);
      return null;
    }
  }

  /**
   * Sets up Surprise Me functionality
   */
  setupSurpriseMe() {
    const surpriseMeBtn = document.getElementById('surprise-me-nav');
    if (surpriseMeBtn) {
      surpriseMeBtn.addEventListener('click', e => {
        e.preventDefault();
        this.launchRandomScenario();
      });
    }
  }

  /**
   * Sets up Tour functionality
   */
  setupTourButton() {
    const tourBtn = document.getElementById('start-tour-nav');
    if (tourBtn) {
      tourBtn.addEventListener('click', e => {
        e.preventDefault();
        this.startOnboardingTour();
      });
    }
  }

  /**
   * Starts the onboarding tour manually
   */
  startOnboardingTour() {
    if (this.onboardingTour) {
      // Reset tour completion to allow restart
      this.onboardingTour.constructor.resetTour();
      this.onboardingTour.startTour(1);
    } else {
      // Create new tour instance if not available
      this.onboardingTour = new OnboardingTour();
      this.onboardingTour.startTour(1);
    }
  }

  /**
   * Launches a random uncompleted scenario
   */
  launchRandomScenario() {
    const randomScenario = this.getRandomUncompletedScenario();

    if (!randomScenario) {
      this.showNotification(
        "🎉 Congratulations! You've completed all scenarios! Try replaying your favorites.",
        'success',
        APP_CONSTANTS.TIMING.NOTIFICATION_DURATION
      );
      return;
    }

    // Close mobile navigation if open
    const mainNav = document.querySelector('.main-nav');
    if (mainNav && mainNav.classList.contains('open')) {
      mainNav.classList.remove('open');
      const navToggle = document.querySelector('.nav-toggle');
      if (navToggle) {
        navToggle.classList.remove('active');
        navToggle.setAttribute('aria-expanded', 'false');
      }
      document.body.style.overflow = '';
    }

    // Show notification about the selected scenario
    this.showNotification(
      `🎉 Surprise! Opening "${randomScenario.scenario.title}" from ${randomScenario.category.title}`,
      'info',
      APP_CONSTANTS.TIMING.NOTIFICATION_DURATION
    );

    // Launch the scenario directly (skip pre-launch modal for surprise factor)
    if (this.categoryGrid) {
      this.categoryGrid.openScenarioModalDirect(
        randomScenario.category.id,
        randomScenario.scenario.id
      );
    } else {
      // Fallback if categoryGrid is not available
      logger.warn('CategoryGrid not available, redirecting to scenario');
      window.location.href = `#scenario-${randomScenario.scenario.id}`;
    }
  }

  /**
   * Gets a random uncompleted scenario from all categories
   * @returns {Object|null} Object with category and scenario, or null if all completed
   */
  getRandomUncompletedScenario() {
    try {
      // Get all categories and their scenarios
      const allCategories = getAllCategories();

      // Load user progress
      const stored = localStorage.getItem('simulateai_category_progress');
      const userProgress = stored ? JSON.parse(stored) : {};

      // Collect all uncompleted scenarios
      const uncompletedScenarios = [];

      allCategories.forEach(category => {
        const scenarios = getCategoryScenarios(category.id);
        scenarios.forEach(scenario => {
          const isCompleted = userProgress[category.id]?.[scenario.id] || false;
          if (!isCompleted) {
            uncompletedScenarios.push({
              category,
              scenario,
            });
          }
        });
      });

      // Return random uncompleted scenario
      if (uncompletedScenarios.length === 0) {
        return null; // All scenarios completed
      }

      const randomIndex = Math.floor(
        Math.random() * uncompletedScenarios.length
      );
      return uncompletedScenarios[randomIndex];
    } catch (error) {
      logger.error('Failed to get random uncompleted scenario:', error);
      return null;
    }
  }

  /**
   * Sets up mobile navigation hamburger menu functionality
   */
  setupMobileNavigation() {
    const navToggle = document.querySelector('.nav-toggle');
    const mainNav = document.querySelector('.main-nav');
    const navBackdrop = document.querySelector('.nav-backdrop');
    const navLinks = document.querySelectorAll('.nav-link');

    if (!navToggle || !mainNav) {
      logger.warn('Mobile navigation elements not found');
      return;
    }

    // Toggle mobile navigation
    const toggleNav = isOpen => {
      const isCurrentlyOpen = mainNav.classList.contains('open');
      const shouldOpen = isOpen !== undefined ? isOpen : !isCurrentlyOpen;

      // Update classes
      mainNav.classList.toggle('open', shouldOpen);
      navToggle.classList.toggle('active', shouldOpen);
      if (navBackdrop) {
        navBackdrop.classList.toggle('open', shouldOpen);
      }

      // Focus management - handle before aria-hidden to avoid accessibility violations
      if (shouldOpen) {
        // Focus first nav link when opening
        const firstNavLink = mainNav.querySelector('.nav-link');
        if (firstNavLink) {
          setTimeout(() => firstNavLink.focus(), 100);
        }
      } else {
        // Move focus away from nav before hiding it
        const { activeElement } = document;
        if (activeElement && mainNav.contains(activeElement)) {
          navToggle.focus(); // Move focus to the nav toggle button
        }
      }

      // Update ARIA attributes after focus management
      navToggle.setAttribute('aria-expanded', shouldOpen.toString());
      mainNav.setAttribute('aria-hidden', (!shouldOpen).toString());

      // Prevent body scroll when nav is open
      document.body.style.overflow = shouldOpen ? 'hidden' : '';

      // Analytics
      simpleAnalytics.trackEvent('mobile_nav_toggled', { isOpen: shouldOpen });
    };

    // Hamburger button click
    navToggle.addEventListener('click', e => {
      e.preventDefault();
      toggleNav();
    });

    // Backdrop click
    if (navBackdrop) {
      navBackdrop.addEventListener('click', () => {
        toggleNav(false);
      });
    }

    // Click outside to close navigation (comprehensive handler)
    document.addEventListener('click', e => {
      // Only handle if navigation is open
      if (!mainNav.classList.contains('open')) {
        return;
      }

      // Don't close if clicking on the nav toggle button (it has its own handler)
      if (navToggle.contains(e.target)) {
        return;
      }

      // Don't close if clicking inside the navigation panel
      if (mainNav.contains(e.target)) {
        return;
      }

      // Don't close if clicking on the backdrop (it has its own handler)
      if (navBackdrop && navBackdrop.contains(e.target)) {
        return;
      }

      // Click was outside navigation - close it
      toggleNav(false);
    });

    // Close nav when clicking on nav links
    navLinks.forEach(link => {
      link.addEventListener('click', e => {
        const href = link.getAttribute('href');
        const text = link.textContent.trim();

        // Skip handling for mega menu trigger on mobile
        const MOBILE_BREAKPOINT = 768;
        if (
          link.closest('.nav-item-dropdown') &&
          window.innerWidth <= MOBILE_BREAKPOINT
        ) {
          return; // Let mega menu handle this
        }

        logger.info('Navigation', `Link clicked: "${text}" -> ${href}`);

        // Skip surprise me button - it has its own handler
        if (link.id === 'surprise-me-nav') {
          return;
        }

        // Skip tour button - it has its own handler
        if (link.id === 'start-tour-nav') {
          return;
        }

        // Handle hash-based navigation
        if (href && href.startsWith('#') && href !== '#') {
          // Prevent default browser jump behavior
          e.preventDefault();

          const targetElement = document.querySelector(href);

          if (targetElement) {
            logger.info('Navigation', `Navigating to section: ${href}`);

            // Close mobile nav first
            toggleNav(false);

            // Then smoothly scroll to target after a brief delay
            const SCROLL_DELAY = 100;
            setTimeout(() => {
              targetElement.scrollIntoView({
                behavior: 'smooth',
                block: 'start',
              });
              logger.info('Navigation', `Scrolled to section: ${href}`);
            }, SCROLL_DELAY);

            // Track successful navigation
            simpleAnalytics.trackEvent('navigation_link_clicked', {
              target: href,
              text,
              success: true,
            });
          } else {
            logger.warn(`Navigation target not found: ${href}`);

            // Close menu immediately for missing targets
            toggleNav(false);

            // Show user feedback for missing sections
            const NOTIFICATION_DURATION = 3000;
            if (this.showNotification) {
              this.showNotification(
                `Section "${text}" is not available on this page.`,
                'warning',
                NOTIFICATION_DURATION
              );
            }

            // Track failed navigation
            simpleAnalytics.trackEvent('navigation_link_clicked', {
              target: href,
              text,
              success: false,
              error: 'target_not_found',
            });
          }
        } else {
          logger.info(`External link or non-hash navigation: ${href}`);

          // For external links, close nav immediately
          toggleNav(false);

          // Track external navigation
          simpleAnalytics.trackEvent('navigation_link_clicked', {
            target: href,
            text,
            type: 'external',
          });
        }
      });
    });

    // Handle escape key
    document.addEventListener('keydown', e => {
      if (e.key === 'Escape' && mainNav.classList.contains('open')) {
        toggleNav(false);
      }
    });

    // Handle window resize - close mobile nav on desktop breakpoint
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.innerWidth > APP_CONSTANTS.VIEWPORT.MOBILE_BREAKPOINT) {
          toggleNav(false);
        }
      }, 250);
    });

    AppDebug.log('Mobile navigation initialized');
  }

  /**
   * Sets up focus trap for mobile navigation
   */
  setupNavFocusTrap(navElement, toggleButton) {
    const focusableElements = navElement.querySelectorAll(
      'a[href], button, [tabindex]:not([tabindex="-1"])'
    );
    const firstFocusable = focusableElements[0];
    const lastFocusable = focusableElements[focusableElements.length - 1];

    navElement.addEventListener('keydown', e => {
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift + Tab - moving backwards
          if (document.activeElement === firstFocusable) {
            e.preventDefault();
            lastFocusable.focus();
          }
        } else {
          // Tab - moving forwards
          if (document.activeElement === lastFocusable) {
            e.preventDefault();
            firstFocusable.focus();
          }
        }
      }
    });
  }

  /**
   * Sets up Surprise Me functionality
   */
  setupSurpriseMe() {
    const surpriseBtn = document.getElementById('surprise-me');
    if (surpriseBtn) {
      surpriseBtn.addEventListener('click', () => {
        this.launchRandomScenario();
      });
    }
  }

  /**
   * Sets up Tour functionality
   */
  setupTourButton() {
    const tourBtn = document.getElementById('start-tour');
    if (tourBtn) {
      tourBtn.addEventListener('click', () => {
        this.startOnboardingTour();
      });
    } else {
      AppDebug.warn('Tour button not found');
    }
  }

  /**
   * Starts the onboarding tour manually
   */
  startOnboardingTour() {
    if (this.onboardingTour) {
      // Reset tour completion to allow restart
      this.onboardingTour.constructor.resetTour();
      this.onboardingTour.startTour(1);
    } else {
      // Create new tour instance if not available
      this.onboardingTour = new OnboardingTour();
      this.onboardingTour.startTour(1);
    }
  }

  /**
   * Launches a random uncompleted scenario
   */
  launchRandomScenario() {
    const randomScenario = this.getRandomUncompletedScenario();

    if (!randomScenario) {
      this.showNotification(
        "🎉 Congratulations! You've completed all scenarios! Try replaying your favorites.",
        'success',
        APP_CONSTANTS.TIMING.NOTIFICATION_DURATION
      );
      return;
    }

    // Show pre-launch modal for the random scenario
    this.showPreLaunchModal(randomScenario.scenario.id);
  }

  /**
   * Gets a random uncompleted scenario from all categories
   * @returns {Object|null} Object with category and scenario, or null if all completed
   */
  getRandomUncompletedScenario() {
    const allCategories = getAllCategories();
    const uncompletedScenarios = [];

    // Collect all uncompleted scenarios from all categories
    allCategories.forEach(category => {
      const scenarios = getCategoryScenarios(category.id);
      scenarios.forEach(scenario => {
        if (!userProgress.hasCompletedScenario(scenario.id)) {
          uncompletedScenarios.push({
            category,
            scenario,
          });
        }
      });
    });

    if (uncompletedScenarios.length === 0) {
      return null;
    }

    // Return random uncompleted scenario
    const randomIndex = Math.floor(Math.random() * uncompletedScenarios.length);
    return uncompletedScenarios[randomIndex];
  }
}

// Initialize the application when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.aiEthicsApp = new AIEthicsApp();
});

// Export for testing and external access
export default AIEthicsApp;
